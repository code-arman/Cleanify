{"ast":null,"code":"import { useTheme } from '@chakra-ui/system';\nimport { isBrowser, __DEV__, memoizedGet, breakpoints, isArray, fromEntries, arrayToObjectNotation } from '@chakra-ui/utils';\nimport * as React from 'react';\nimport React__default from 'react';\nimport { useEnvironment } from '@chakra-ui/react-env';\nvar useSafeLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n/**\n * React hook that tracks state of a CSS media query\n *\n * @param query the media query to match\n */\n\nfunction useMediaQuery(query) {\n  var env = useEnvironment();\n  var queries = Array.isArray(query) ? query : [query];\n  var isSupported = isBrowser && \"matchMedia\" in env.window;\n\n  var _React$useState = React.useState(queries.map(function (query) {\n    return isSupported ? !!env.window.matchMedia(query).matches : false;\n  })),\n      matches = _React$useState[0],\n      setMatches = _React$useState[1]; // Specifying matches in the dependency list will cause the event listeners\n  // to unload and then load each time the dependency changes. This causes\n  // Media Query Events to be missed. The event listeners should only be unloaded\n  // when the component unloads.\n\n\n  useSafeLayoutEffect(function () {\n    if (!isSupported) return undefined;\n    var mediaQueryList = queries.map(function (query) {\n      return env.window.matchMedia(query);\n    });\n    var listenerList = mediaQueryList.map(function (_, index) {\n      var listener = function listener(mqlEvent) {\n        var queryIndex = mediaQueryList.findIndex(function (mediaQuery) {\n          return mediaQuery.media === mqlEvent.media;\n        }); // As the event listener is on the media query list, any time the\n        // listener is called, we know there is a change. There's no need\n        // to compare the previous matches with current. Using\n        // setMatches(matches => {...}) provides access to the current matches\n        // state.  Trying to access matches outside the setMatches function\n        // would provide data from the the time of instantiation (stale).\n\n        setMatches(function (matches) {\n          var currentMatches = matches.map(function (x) {\n            return x;\n          });\n          currentMatches[queryIndex] = mqlEvent.matches;\n          return currentMatches;\n        });\n      }; // Listening to the 'change' event on the Media Query List Object\n      // is more performant as the callback is only invoked when a specified\n      // media query is matched. Using addEventListener on the window object\n      // to listen for the resize event will call the callback on every\n      // viewport resize.\n\n\n      if (typeof mediaQueryList[index].addEventListener === \"function\") {\n        mediaQueryList[index].addEventListener(\"change\", listener);\n      } else {\n        mediaQueryList[index].addListener(listener);\n      }\n\n      return listener;\n    });\n    return function () {\n      mediaQueryList.forEach(function (_, index) {\n        if (typeof mediaQueryList[index].removeEventListener === \"function\") {\n          mediaQueryList[index].removeEventListener(\"change\", listenerList[index]);\n        } else {\n          mediaQueryList[index].removeListener(listenerList[index]);\n        }\n      });\n    };\n  }, []);\n  return matches;\n}\n/**\n * Visibility\n *\n * React component to control the visibility of its\n * children based on the current breakpoint\n */\n\n\nvar Visibility = function Visibility(props) {\n  var breakpoint = props.breakpoint,\n      hide = props.hide,\n      children = props.children;\n\n  var _useMediaQuery = useMediaQuery(breakpoint),\n      show = _useMediaQuery[0];\n\n  var isVisible = hide ? !show : show;\n  var rendered = isVisible ? children : null;\n  return rendered;\n};\n\nvar Hide = function Hide(props) {\n  var children = props.children;\n  var query = useQuery(props);\n  return /*#__PURE__*/React.createElement(Visibility, {\n    breakpoint: query,\n    hide: true\n  }, children);\n};\n\nif (__DEV__) {\n  Hide.displayName = \"Hide\";\n}\n\nvar Show = function Show(props) {\n  var children = props.children;\n  var query = useQuery(props);\n  return /*#__PURE__*/React.createElement(Visibility, {\n    breakpoint: query\n  }, children);\n};\n\nif (__DEV__) {\n  Show.displayName = \"Show\";\n}\n\nvar getBreakpoint = function getBreakpoint(theme, value) {\n  return memoizedGet(theme, \"breakpoints.\" + value, value);\n};\n\nfunction useQuery(props) {\n  var _props$breakpoint = props.breakpoint,\n      breakpoint = _props$breakpoint === void 0 ? \"\" : _props$breakpoint,\n      below = props.below,\n      above = props.above;\n  var theme = useTheme();\n  var bpBelow = getBreakpoint(theme, below);\n  var bpAbove = getBreakpoint(theme, above);\n  var query = breakpoint;\n\n  if (bpBelow) {\n    query = \"(max-width: \" + bpBelow + \")\";\n  } else if (bpAbove) {\n    query = \"(min-width: \" + bpAbove + \")\";\n  }\n\n  return query;\n}\n/**\n * React hook used to get the user's animation preference.\n */\n\n\nfunction usePrefersReducedMotion() {\n  var _useMediaQuery = useMediaQuery(\"(prefers-reduced-motion: reduce)\"),\n      prefersReducedMotion = _useMediaQuery[0];\n\n  return prefersReducedMotion;\n}\n/**\n * React hook for getting the user's color mode preference.\n */\n\n\nfunction useColorModePreference() {\n  var _useMediaQuery2 = useMediaQuery([\"(prefers-color-scheme: light)\", \"(prefers-color-scheme: dark)\"]),\n      isLight = _useMediaQuery2[0],\n      isDark = _useMediaQuery2[1];\n\n  if (isLight) return \"light\";\n  if (isDark) return \"dark\";\n  return undefined;\n}\n/**\n * React hook used to get the current responsive media breakpoint.\n *\n * @param [defaultBreakpoint=\"base\"] default breakpoint name\n * (in non-window environments like SSR)\n *\n * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)\n * to get the default breakpoint value from the user-agent\n */\n\n\nfunction useBreakpoint(defaultBreakpoint // default value ensures SSR+CSR consistency\n) {\n  if (defaultBreakpoint === void 0) {\n    defaultBreakpoint = \"base\";\n  }\n\n  var _useTheme = useTheme(),\n      __breakpoints = _useTheme.__breakpoints;\n\n  var env = useEnvironment();\n  var queries = React__default.useMemo(function () {\n    var _breakpoints$details;\n\n    return (_breakpoints$details = __breakpoints == null ? void 0 : __breakpoints.details.map(function (_ref) {\n      var minMaxQuery = _ref.minMaxQuery,\n          breakpoint = _ref.breakpoint;\n      return {\n        breakpoint: breakpoint,\n        query: minMaxQuery.replace(\"@media screen and \", \"\")\n      };\n    })) != null ? _breakpoints$details : [];\n  }, [__breakpoints]);\n\n  var _React$useState = React__default.useState(function () {\n    if (defaultBreakpoint) {\n      // use default breakpoint to ensure render consistency in SSR + CSR environments\n      // => first render on the client has to match the render on the server\n      var fallbackBreakpointDetail = queries.find(function (_ref2) {\n        var breakpoint = _ref2.breakpoint;\n        return breakpoint === defaultBreakpoint;\n      });\n\n      if (fallbackBreakpointDetail) {\n        return fallbackBreakpointDetail.breakpoint;\n      }\n    }\n\n    if (env.window.matchMedia) {\n      // set correct breakpoint on first render if no default breakpoint was provided\n      var matchingBreakpointDetail = queries.find(function (_ref3) {\n        var query = _ref3.query;\n        return env.window.matchMedia(query).matches;\n      });\n\n      if (matchingBreakpointDetail) {\n        return matchingBreakpointDetail.breakpoint;\n      }\n    }\n\n    return undefined;\n  }),\n      currentBreakpoint = _React$useState[0],\n      setCurrentBreakpoint = _React$useState[1];\n\n  React__default.useEffect(function () {\n    var allUnregisterFns = queries.map(function (_ref4) {\n      var breakpoint = _ref4.breakpoint,\n          query = _ref4.query;\n      var mediaQueryList = env.window.matchMedia(query);\n\n      if (mediaQueryList.matches) {\n        setCurrentBreakpoint(breakpoint);\n      }\n\n      var handleChange = function handleChange(ev) {\n        if (ev.matches) {\n          setCurrentBreakpoint(breakpoint);\n        }\n      }; // add media query listener\n\n\n      if (typeof mediaQueryList.addEventListener === \"function\") {\n        mediaQueryList.addEventListener(\"change\", handleChange);\n      } else {\n        mediaQueryList.addListener(handleChange);\n      } // return unregister fn\n\n\n      return function () {\n        if (typeof mediaQueryList.removeEventListener === \"function\") {\n          mediaQueryList.removeEventListener(\"change\", handleChange);\n        } else {\n          mediaQueryList.removeListener(handleChange);\n        }\n      };\n    });\n    return function () {\n      allUnregisterFns.forEach(function (unregister) {\n        return unregister();\n      });\n    };\n  }, [queries, __breakpoints, env.window]);\n  return currentBreakpoint;\n}\n\nfunction getClosestValue(values, breakpoint, breakpoints$1) {\n  if (breakpoints$1 === void 0) {\n    breakpoints$1 = breakpoints;\n  }\n\n  var index = Object.keys(values).indexOf(breakpoint);\n\n  if (index !== -1) {\n    return values[breakpoint];\n  }\n\n  var stopIndex = breakpoints$1.indexOf(breakpoint);\n\n  while (stopIndex >= 0) {\n    var key = breakpoints$1[stopIndex];\n\n    if (values[key] != null) {\n      index = stopIndex;\n      break;\n    }\n\n    stopIndex -= 1;\n  }\n\n  if (index !== -1) {\n    var _key = breakpoints$1[index];\n    return values[_key];\n  }\n\n  return undefined;\n}\n/**\n * React hook for getting the value for the current breakpoint from the\n * provided responsive values object.\n *\n * @param values\n * @param [defaultBreakpoint] default breakpoint name\n * (in non-window environments like SSR)\n *\n * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)\n * to get the default breakpoint value from the user-agent\n *\n * @example\n * const width = useBreakpointValue({ base: '150px', md: '250px' })\n */\n\n\nfunction useBreakpointValue(values, defaultBreakpoint) {\n  var _theme$__breakpoints;\n\n  var breakpoint = useBreakpoint(defaultBreakpoint);\n  var theme = useTheme();\n  if (!breakpoint) return undefined;\n  /**\n   * Get the sorted breakpoint keys from the provided breakpoints\n   */\n\n  var breakpoints = Array.from(((_theme$__breakpoints = theme.__breakpoints) == null ? void 0 : _theme$__breakpoints.keys) || []);\n  var obj = isArray(values) ? fromEntries(Object.entries(arrayToObjectNotation(values, breakpoints)).map(function (_ref) {\n    var key = _ref[0],\n        value = _ref[1];\n    return [key, value];\n  })) : values;\n  return getClosestValue(obj, breakpoint, breakpoints);\n}\n\nexport { Hide, Show, useBreakpoint, useBreakpointValue, useColorModePreference, useMediaQuery, usePrefersReducedMotion, useQuery };","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/@chakra-ui/media-query/dist/chakra-ui-media-query.esm.js"],"names":["useTheme","isBrowser","__DEV__","memoizedGet","breakpoints","isArray","fromEntries","arrayToObjectNotation","React","React__default","useEnvironment","useSafeLayoutEffect","useLayoutEffect","useEffect","useMediaQuery","query","env","queries","Array","isSupported","window","_React$useState","useState","map","matchMedia","matches","setMatches","undefined","mediaQueryList","listenerList","_","index","listener","mqlEvent","queryIndex","findIndex","mediaQuery","media","currentMatches","x","addEventListener","addListener","forEach","removeEventListener","removeListener","Visibility","props","breakpoint","hide","children","_useMediaQuery","show","isVisible","rendered","Hide","useQuery","createElement","displayName","Show","getBreakpoint","theme","value","_props$breakpoint","below","above","bpBelow","bpAbove","usePrefersReducedMotion","prefersReducedMotion","useColorModePreference","_useMediaQuery2","isLight","isDark","useBreakpoint","defaultBreakpoint","_useTheme","__breakpoints","useMemo","_breakpoints$details","details","_ref","minMaxQuery","replace","fallbackBreakpointDetail","find","_ref2","matchingBreakpointDetail","_ref3","currentBreakpoint","setCurrentBreakpoint","allUnregisterFns","_ref4","handleChange","ev","unregister","getClosestValue","values","breakpoints$1","Object","keys","indexOf","stopIndex","key","_key","useBreakpointValue","_theme$__breakpoints","from","obj","entries"],"mappings":"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","sourcesContent":["import { useTheme } from '@chakra-ui/system';\nimport { isBrowser, __DEV__, memoizedGet, breakpoints, isArray, fromEntries, arrayToObjectNotation } from '@chakra-ui/utils';\nimport * as React from 'react';\nimport React__default from 'react';\nimport { useEnvironment } from '@chakra-ui/react-env';\n\nvar useSafeLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n/**\n * React hook that tracks state of a CSS media query\n *\n * @param query the media query to match\n */\n\nfunction useMediaQuery(query) {\n  var env = useEnvironment();\n  var queries = Array.isArray(query) ? query : [query];\n  var isSupported = isBrowser && \"matchMedia\" in env.window;\n\n  var _React$useState = React.useState(queries.map(function (query) {\n    return isSupported ? !!env.window.matchMedia(query).matches : false;\n  })),\n      matches = _React$useState[0],\n      setMatches = _React$useState[1]; // Specifying matches in the dependency list will cause the event listeners\n  // to unload and then load each time the dependency changes. This causes\n  // Media Query Events to be missed. The event listeners should only be unloaded\n  // when the component unloads.\n\n\n  useSafeLayoutEffect(function () {\n    if (!isSupported) return undefined;\n    var mediaQueryList = queries.map(function (query) {\n      return env.window.matchMedia(query);\n    });\n    var listenerList = mediaQueryList.map(function (_, index) {\n      var listener = function listener(mqlEvent) {\n        var queryIndex = mediaQueryList.findIndex(function (mediaQuery) {\n          return mediaQuery.media === mqlEvent.media;\n        }); // As the event listener is on the media query list, any time the\n        // listener is called, we know there is a change. There's no need\n        // to compare the previous matches with current. Using\n        // setMatches(matches => {...}) provides access to the current matches\n        // state.  Trying to access matches outside the setMatches function\n        // would provide data from the the time of instantiation (stale).\n\n        setMatches(function (matches) {\n          var currentMatches = matches.map(function (x) {\n            return x;\n          });\n          currentMatches[queryIndex] = mqlEvent.matches;\n          return currentMatches;\n        });\n      }; // Listening to the 'change' event on the Media Query List Object\n      // is more performant as the callback is only invoked when a specified\n      // media query is matched. Using addEventListener on the window object\n      // to listen for the resize event will call the callback on every\n      // viewport resize.\n\n\n      if (typeof mediaQueryList[index].addEventListener === \"function\") {\n        mediaQueryList[index].addEventListener(\"change\", listener);\n      } else {\n        mediaQueryList[index].addListener(listener);\n      }\n\n      return listener;\n    });\n    return function () {\n      mediaQueryList.forEach(function (_, index) {\n        if (typeof mediaQueryList[index].removeEventListener === \"function\") {\n          mediaQueryList[index].removeEventListener(\"change\", listenerList[index]);\n        } else {\n          mediaQueryList[index].removeListener(listenerList[index]);\n        }\n      });\n    };\n  }, []);\n  return matches;\n}\n\n/**\n * Visibility\n *\n * React component to control the visibility of its\n * children based on the current breakpoint\n */\nvar Visibility = function Visibility(props) {\n  var breakpoint = props.breakpoint,\n      hide = props.hide,\n      children = props.children;\n\n  var _useMediaQuery = useMediaQuery(breakpoint),\n      show = _useMediaQuery[0];\n\n  var isVisible = hide ? !show : show;\n  var rendered = isVisible ? children : null;\n  return rendered;\n};\n\nvar Hide = function Hide(props) {\n  var children = props.children;\n  var query = useQuery(props);\n  return /*#__PURE__*/React.createElement(Visibility, {\n    breakpoint: query,\n    hide: true\n  }, children);\n};\n\nif (__DEV__) {\n  Hide.displayName = \"Hide\";\n}\n\nvar Show = function Show(props) {\n  var children = props.children;\n  var query = useQuery(props);\n  return /*#__PURE__*/React.createElement(Visibility, {\n    breakpoint: query\n  }, children);\n};\n\nif (__DEV__) {\n  Show.displayName = \"Show\";\n}\n\nvar getBreakpoint = function getBreakpoint(theme, value) {\n  return memoizedGet(theme, \"breakpoints.\" + value, value);\n};\n\nfunction useQuery(props) {\n  var _props$breakpoint = props.breakpoint,\n      breakpoint = _props$breakpoint === void 0 ? \"\" : _props$breakpoint,\n      below = props.below,\n      above = props.above;\n  var theme = useTheme();\n  var bpBelow = getBreakpoint(theme, below);\n  var bpAbove = getBreakpoint(theme, above);\n  var query = breakpoint;\n\n  if (bpBelow) {\n    query = \"(max-width: \" + bpBelow + \")\";\n  } else if (bpAbove) {\n    query = \"(min-width: \" + bpAbove + \")\";\n  }\n\n  return query;\n}\n\n/**\n * React hook used to get the user's animation preference.\n */\n\nfunction usePrefersReducedMotion() {\n  var _useMediaQuery = useMediaQuery(\"(prefers-reduced-motion: reduce)\"),\n      prefersReducedMotion = _useMediaQuery[0];\n\n  return prefersReducedMotion;\n}\n/**\n * React hook for getting the user's color mode preference.\n */\n\nfunction useColorModePreference() {\n  var _useMediaQuery2 = useMediaQuery([\"(prefers-color-scheme: light)\", \"(prefers-color-scheme: dark)\"]),\n      isLight = _useMediaQuery2[0],\n      isDark = _useMediaQuery2[1];\n\n  if (isLight) return \"light\";\n  if (isDark) return \"dark\";\n  return undefined;\n}\n\n/**\n * React hook used to get the current responsive media breakpoint.\n *\n * @param [defaultBreakpoint=\"base\"] default breakpoint name\n * (in non-window environments like SSR)\n *\n * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)\n * to get the default breakpoint value from the user-agent\n */\n\nfunction useBreakpoint(defaultBreakpoint // default value ensures SSR+CSR consistency\n) {\n  if (defaultBreakpoint === void 0) {\n    defaultBreakpoint = \"base\";\n  }\n\n  var _useTheme = useTheme(),\n      __breakpoints = _useTheme.__breakpoints;\n\n  var env = useEnvironment();\n  var queries = React__default.useMemo(function () {\n    var _breakpoints$details;\n\n    return (_breakpoints$details = __breakpoints == null ? void 0 : __breakpoints.details.map(function (_ref) {\n      var minMaxQuery = _ref.minMaxQuery,\n          breakpoint = _ref.breakpoint;\n      return {\n        breakpoint: breakpoint,\n        query: minMaxQuery.replace(\"@media screen and \", \"\")\n      };\n    })) != null ? _breakpoints$details : [];\n  }, [__breakpoints]);\n\n  var _React$useState = React__default.useState(function () {\n    if (defaultBreakpoint) {\n      // use default breakpoint to ensure render consistency in SSR + CSR environments\n      // => first render on the client has to match the render on the server\n      var fallbackBreakpointDetail = queries.find(function (_ref2) {\n        var breakpoint = _ref2.breakpoint;\n        return breakpoint === defaultBreakpoint;\n      });\n\n      if (fallbackBreakpointDetail) {\n        return fallbackBreakpointDetail.breakpoint;\n      }\n    }\n\n    if (env.window.matchMedia) {\n      // set correct breakpoint on first render if no default breakpoint was provided\n      var matchingBreakpointDetail = queries.find(function (_ref3) {\n        var query = _ref3.query;\n        return env.window.matchMedia(query).matches;\n      });\n\n      if (matchingBreakpointDetail) {\n        return matchingBreakpointDetail.breakpoint;\n      }\n    }\n\n    return undefined;\n  }),\n      currentBreakpoint = _React$useState[0],\n      setCurrentBreakpoint = _React$useState[1];\n\n  React__default.useEffect(function () {\n    var allUnregisterFns = queries.map(function (_ref4) {\n      var breakpoint = _ref4.breakpoint,\n          query = _ref4.query;\n      var mediaQueryList = env.window.matchMedia(query);\n\n      if (mediaQueryList.matches) {\n        setCurrentBreakpoint(breakpoint);\n      }\n\n      var handleChange = function handleChange(ev) {\n        if (ev.matches) {\n          setCurrentBreakpoint(breakpoint);\n        }\n      }; // add media query listener\n\n\n      if (typeof mediaQueryList.addEventListener === \"function\") {\n        mediaQueryList.addEventListener(\"change\", handleChange);\n      } else {\n        mediaQueryList.addListener(handleChange);\n      } // return unregister fn\n\n\n      return function () {\n        if (typeof mediaQueryList.removeEventListener === \"function\") {\n          mediaQueryList.removeEventListener(\"change\", handleChange);\n        } else {\n          mediaQueryList.removeListener(handleChange);\n        }\n      };\n    });\n    return function () {\n      allUnregisterFns.forEach(function (unregister) {\n        return unregister();\n      });\n    };\n  }, [queries, __breakpoints, env.window]);\n  return currentBreakpoint;\n}\n\nfunction getClosestValue(values, breakpoint, breakpoints$1) {\n  if (breakpoints$1 === void 0) {\n    breakpoints$1 = breakpoints;\n  }\n\n  var index = Object.keys(values).indexOf(breakpoint);\n\n  if (index !== -1) {\n    return values[breakpoint];\n  }\n\n  var stopIndex = breakpoints$1.indexOf(breakpoint);\n\n  while (stopIndex >= 0) {\n    var key = breakpoints$1[stopIndex];\n\n    if (values[key] != null) {\n      index = stopIndex;\n      break;\n    }\n\n    stopIndex -= 1;\n  }\n\n  if (index !== -1) {\n    var _key = breakpoints$1[index];\n    return values[_key];\n  }\n\n  return undefined;\n}\n\n/**\n * React hook for getting the value for the current breakpoint from the\n * provided responsive values object.\n *\n * @param values\n * @param [defaultBreakpoint] default breakpoint name\n * (in non-window environments like SSR)\n *\n * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)\n * to get the default breakpoint value from the user-agent\n *\n * @example\n * const width = useBreakpointValue({ base: '150px', md: '250px' })\n */\n\nfunction useBreakpointValue(values, defaultBreakpoint) {\n  var _theme$__breakpoints;\n\n  var breakpoint = useBreakpoint(defaultBreakpoint);\n  var theme = useTheme();\n  if (!breakpoint) return undefined;\n  /**\n   * Get the sorted breakpoint keys from the provided breakpoints\n   */\n\n  var breakpoints = Array.from(((_theme$__breakpoints = theme.__breakpoints) == null ? void 0 : _theme$__breakpoints.keys) || []);\n  var obj = isArray(values) ? fromEntries(Object.entries(arrayToObjectNotation(values, breakpoints)).map(function (_ref) {\n    var key = _ref[0],\n        value = _ref[1];\n    return [key, value];\n  })) : values;\n  return getClosestValue(obj, breakpoint, breakpoints);\n}\n\nexport { Hide, Show, useBreakpoint, useBreakpointValue, useColorModePreference, useMediaQuery, usePrefersReducedMotion, useQuery };\n"]},"metadata":{},"sourceType":"module"}