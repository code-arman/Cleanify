{"ast":null,"code":"import { mix } from 'popmotion';\nimport { complex } from 'style-value-types';\nimport { cssVariableRegex } from '../../render/dom/utils/css-variables-conversion.mjs';\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n  correct: function (latest, _a) {\n    var treeScale = _a.treeScale,\n        projectionDelta = _a.projectionDelta;\n    var original = latest;\n    /**\n     * We need to first strip and store CSS variables from the string.\n     */\n\n    var containsCSSVariables = latest.includes(\"var(\");\n    var cssVariables = [];\n\n    if (containsCSSVariables) {\n      latest = latest.replace(cssVariableRegex, function (match) {\n        cssVariables.push(match);\n        return varToken;\n      });\n    }\n\n    var shadow = complex.parse(latest); // TODO: Doesn't support multiple shadows\n\n    if (shadow.length > 5) return original;\n    var template = complex.createTransformer(latest);\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0; // Calculate the overall context scale\n\n    var xScale = projectionDelta.x.scale * treeScale.x;\n    var yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n\n    var averageScale = mix(xScale, yScale, 0.5); // Blur\n\n    if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale; // Spread\n\n    if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n    var output = template(shadow);\n\n    if (containsCSSVariables) {\n      var i_1 = 0;\n      output = output.replace(varToken, function () {\n        var cssVariable = cssVariables[i_1];\n        i_1++;\n        return cssVariable;\n      });\n    }\n\n    return output;\n  }\n};\nexport { correctBoxShadow };","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs"],"names":["mix","complex","cssVariableRegex","varToken","correctBoxShadow","correct","latest","_a","treeScale","projectionDelta","original","containsCSSVariables","includes","cssVariables","replace","match","push","shadow","parse","length","template","createTransformer","offset","xScale","x","scale","yScale","y","averageScale","output","i_1","cssVariable"],"mappings":"AAAA,SAASA,GAAT,QAAoB,WAApB;AACA,SAASC,OAAT,QAAwB,mBAAxB;AACA,SAASC,gBAAT,QAAiC,qDAAjC;AAEA,IAAIC,QAAQ,GAAG,OAAf;AACA,IAAIC,gBAAgB,GAAG;AACnBC,EAAAA,OAAO,EAAE,UAAUC,MAAV,EAAkBC,EAAlB,EAAsB;AAC3B,QAAIC,SAAS,GAAGD,EAAE,CAACC,SAAnB;AAAA,QAA8BC,eAAe,GAAGF,EAAE,CAACE,eAAnD;AACA,QAAIC,QAAQ,GAAGJ,MAAf;AACA;AACR;AACA;;AACQ,QAAIK,oBAAoB,GAAGL,MAAM,CAACM,QAAP,CAAgB,MAAhB,CAA3B;AACA,QAAIC,YAAY,GAAG,EAAnB;;AACA,QAAIF,oBAAJ,EAA0B;AACtBL,MAAAA,MAAM,GAAGA,MAAM,CAACQ,OAAP,CAAeZ,gBAAf,EAAiC,UAAUa,KAAV,EAAiB;AACvDF,QAAAA,YAAY,CAACG,IAAb,CAAkBD,KAAlB;AACA,eAAOZ,QAAP;AACH,OAHQ,CAAT;AAIH;;AACD,QAAIc,MAAM,GAAGhB,OAAO,CAACiB,KAAR,CAAcZ,MAAd,CAAb,CAd2B,CAe3B;;AACA,QAAIW,MAAM,CAACE,MAAP,GAAgB,CAApB,EACI,OAAOT,QAAP;AACJ,QAAIU,QAAQ,GAAGnB,OAAO,CAACoB,iBAAR,CAA0Bf,MAA1B,CAAf;AACA,QAAIgB,MAAM,GAAG,OAAOL,MAAM,CAAC,CAAD,CAAb,KAAqB,QAArB,GAAgC,CAAhC,GAAoC,CAAjD,CAnB2B,CAoB3B;;AACA,QAAIM,MAAM,GAAGd,eAAe,CAACe,CAAhB,CAAkBC,KAAlB,GAA0BjB,SAAS,CAACgB,CAAjD;AACA,QAAIE,MAAM,GAAGjB,eAAe,CAACkB,CAAhB,CAAkBF,KAAlB,GAA0BjB,SAAS,CAACmB,CAAjD;AACAV,IAAAA,MAAM,CAAC,IAAIK,MAAL,CAAN,IAAsBC,MAAtB;AACAN,IAAAA,MAAM,CAAC,IAAIK,MAAL,CAAN,IAAsBI,MAAtB;AACA;AACR;AACA;AACA;AACA;AACA;;AACQ,QAAIE,YAAY,GAAG5B,GAAG,CAACuB,MAAD,EAASG,MAAT,EAAiB,GAAjB,CAAtB,CA/B2B,CAgC3B;;AACA,QAAI,OAAOT,MAAM,CAAC,IAAIK,MAAL,CAAb,KAA8B,QAAlC,EACIL,MAAM,CAAC,IAAIK,MAAL,CAAN,IAAsBM,YAAtB,CAlCuB,CAmC3B;;AACA,QAAI,OAAOX,MAAM,CAAC,IAAIK,MAAL,CAAb,KAA8B,QAAlC,EACIL,MAAM,CAAC,IAAIK,MAAL,CAAN,IAAsBM,YAAtB;AACJ,QAAIC,MAAM,GAAGT,QAAQ,CAACH,MAAD,CAArB;;AACA,QAAIN,oBAAJ,EAA0B;AACtB,UAAImB,GAAG,GAAG,CAAV;AACAD,MAAAA,MAAM,GAAGA,MAAM,CAACf,OAAP,CAAeX,QAAf,EAAyB,YAAY;AAC1C,YAAI4B,WAAW,GAAGlB,YAAY,CAACiB,GAAD,CAA9B;AACAA,QAAAA,GAAG;AACH,eAAOC,WAAP;AACH,OAJQ,CAAT;AAKH;;AACD,WAAOF,MAAP;AACH;AAjDkB,CAAvB;AAoDA,SAASzB,gBAAT","sourcesContent":["import { mix } from 'popmotion';\nimport { complex } from 'style-value-types';\nimport { cssVariableRegex } from '../../render/dom/utils/css-variables-conversion.mjs';\n\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n    correct: function (latest, _a) {\n        var treeScale = _a.treeScale, projectionDelta = _a.projectionDelta;\n        var original = latest;\n        /**\n         * We need to first strip and store CSS variables from the string.\n         */\n        var containsCSSVariables = latest.includes(\"var(\");\n        var cssVariables = [];\n        if (containsCSSVariables) {\n            latest = latest.replace(cssVariableRegex, function (match) {\n                cssVariables.push(match);\n                return varToken;\n            });\n        }\n        var shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        var template = complex.createTransformer(latest);\n        var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        var xScale = projectionDelta.x.scale * treeScale.x;\n        var yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        var averageScale = mix(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            shadow[3 + offset] /= averageScale;\n        var output = template(shadow);\n        if (containsCSSVariables) {\n            var i_1 = 0;\n            output = output.replace(varToken, function () {\n                var cssVariable = cssVariables[i_1];\n                i_1++;\n                return cssVariable;\n            });\n        }\n        return output;\n    },\n};\n\nexport { correctBoxShadow };\n"]},"metadata":{},"sourceType":"module"}