{"ast":null,"code":"import _toConsumableArray from \"/Users/armanrafati/Documents/Cleanify/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { complex, color } from 'style-value-types';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { isNum } from './inc.mjs';\nimport { pipe } from './pipe.mjs';\nimport { warning } from 'hey-listen';\n\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return function (v) {\n      return mix(origin, target, v);\n    };\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\n\nvar mixArray = function mixArray(from, to) {\n  var output = _toConsumableArray(from);\n\n  var numValues = output.length;\n  var blendValue = from.map(function (fromThis, i) {\n    return getMixer(fromThis, to[i]);\n  });\n  return function (v) {\n    for (var i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n\n    return output;\n  };\n};\n\nvar mixObject = function mixObject(origin, target) {\n  var output = Object.assign(Object.assign({}, origin), target);\n  var blendValue = {};\n\n  for (var key in output) {\n    if (origin[key] !== undefined && target[key] !== undefined) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n\n  return function (v) {\n    for (var _key in blendValue) {\n      output[_key] = blendValue[_key](v);\n    }\n\n    return output;\n  };\n};\n\nfunction analyse(value) {\n  var parsed = complex.parse(value);\n  var numValues = parsed.length;\n  var numNumbers = 0;\n  var numRGB = 0;\n  var numHSL = 0;\n\n  for (var i = 0; i < numValues; i++) {\n    if (numNumbers || typeof parsed[i] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i].hue !== undefined) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n\n  return {\n    parsed: parsed,\n    numNumbers: numNumbers,\n    numRGB: numRGB,\n    numHSL: numHSL\n  };\n}\n\nvar mixComplex = function mixComplex(origin, target) {\n  var template = complex.createTransformer(target);\n  var originStats = analyse(origin);\n  var targetStats = analyse(target);\n  var canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n  } else {\n    warning(true, \"Complex values '\".concat(origin, \"' and '\").concat(target, \"' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.\"));\n    return function (p) {\n      return \"\".concat(p > 0 ? target : origin);\n    };\n  }\n};\n\nexport { mixArray, mixComplex, mixObject };","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/popmotion/dist/es/utils/mix-complex.mjs"],"names":["complex","color","mix","mixColor","isNum","pipe","warning","getMixer","origin","target","v","test","mixComplex","mixArray","from","to","output","numValues","length","blendValue","map","fromThis","i","mixObject","Object","assign","key","undefined","analyse","value","parsed","parse","numNumbers","numRGB","numHSL","hue","template","createTransformer","originStats","targetStats","canInterpolate","p"],"mappings":"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","sourcesContent":["import { complex, color } from 'style-value-types';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { isNum } from './inc.mjs';\nimport { pipe } from './pipe.mjs';\nimport { warning } from 'hey-listen';\n\nfunction getMixer(origin, target) {\n    if (isNum(origin)) {\n        return (v) => mix(origin, target, v);\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = Object.assign(Object.assign({}, origin), target);\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nfunction analyse(value) {\n    const parsed = complex.parse(value);\n    const numValues = parsed.length;\n    let numNumbers = 0;\n    let numRGB = 0;\n    let numHSL = 0;\n    for (let i = 0; i < numValues; i++) {\n        if (numNumbers || typeof parsed[i] === \"number\") {\n            numNumbers++;\n        }\n        else {\n            if (parsed[i].hue !== undefined) {\n                numHSL++;\n            }\n            else {\n                numRGB++;\n            }\n        }\n    }\n    return { parsed, numNumbers, numRGB, numHSL };\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyse(origin);\n    const targetStats = analyse(target);\n    const canInterpolate = originStats.numHSL === targetStats.numHSL &&\n        originStats.numRGB === targetStats.numRGB &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return (p) => `${p > 0 ? target : origin}`;\n    }\n};\n\nexport { mixArray, mixComplex, mixObject };\n"]},"metadata":{},"sourceType":"module"}