{"ast":null,"code":"import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport { within, withinMaxClamp } from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\nimport { min as mathMin, max as mathMax } from \"../utils/math.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? mathMin(min, tetherMin) : min, offset, tether ? mathMax(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js"],"names":["top","left","right","bottom","start","getBasePlacement","getMainAxisFromPlacement","getAltAxis","within","withinMaxClamp","getLayoutRect","getOffsetParent","detectOverflow","getVariation","getFreshSideObject","min","mathMin","max","mathMax","preventOverflow","_ref","state","options","name","_options$mainAxis","mainAxis","checkMainAxis","_options$altAxis","altAxis","checkAltAxis","boundary","rootBoundary","altBoundary","padding","_options$tether","tether","_options$tetherOffset","tetherOffset","overflow","basePlacement","placement","variation","isBasePlacement","popperOffsets","modifiersData","referenceRect","rects","reference","popperRect","popper","tetherOffsetValue","Object","assign","normalizedTetherOffsetValue","offsetModifierState","offset","data","x","y","_offsetModifierState$","mainSide","altSide","len","additive","minLen","maxLen","arrowElement","elements","arrow","arrowRect","width","height","arrowPaddingObject","arrowPaddingMin","arrowPaddingMax","arrowLen","minOffset","maxOffset","arrowOffsetParent","clientOffset","clientTop","clientLeft","offsetModifierValue","tetherMin","tetherMax","preventedOffset","_offsetModifierState$2","_mainSide","_altSide","_offset","_len","_min","_max","isOriginSide","indexOf","_offsetModifierValue","_tetherMin","_tetherMax","_preventedOffset","enabled","phase","fn","requiresIfExists"],"mappings":"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","sourcesContent":["import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport { within, withinMaxClamp } from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\nimport { min as mathMin, max as mathMax } from \"../utils/math.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? mathMin(min, tetherMin) : min, offset, tether ? mathMax(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};"]},"metadata":{},"sourceType":"module"}