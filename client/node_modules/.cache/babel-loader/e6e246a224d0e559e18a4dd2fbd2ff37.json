{"ast":null,"code":"import { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useContext } from 'react';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\n\nfunction useProjection(projectionId, _a, visualElement, ProjectionNodeConstructor) {\n  var _b;\n\n  var layoutId = _a.layoutId,\n      layout = _a.layout,\n      drag = _a.drag,\n      dragConstraints = _a.dragConstraints,\n      layoutScroll = _a.layoutScroll;\n  var initialPromotionConfig = useContext(SwitchLayoutGroupContext);\n\n  if (!ProjectionNodeConstructor || !visualElement || (visualElement === null || visualElement === void 0 ? void 0 : visualElement.projection)) {\n    return;\n  }\n\n  visualElement.projection = new ProjectionNodeConstructor(projectionId, visualElement.getLatestValues(), (_b = visualElement.parent) === null || _b === void 0 ? void 0 : _b.projection);\n  visualElement.projection.setOptions({\n    layoutId: layoutId,\n    layout: layout,\n    alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n    visualElement: visualElement,\n    scheduleRender: function () {\n      return visualElement.scheduleRender();\n    },\n\n    /**\n     * TODO: Update options in an effect. This could be tricky as it'll be too late\n     * to update by the time layout animations run.\n     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n     * ensuring it gets called if there's no potential layout animations.\n     *\n     */\n    animationType: typeof layout === \"string\" ? layout : \"both\",\n    initialPromotionConfig: initialPromotionConfig,\n    layoutScroll: layoutScroll\n  });\n}\n\nexport { useProjection };","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/framer-motion/dist/es/motion/features/use-projection.mjs"],"names":["isRefObject","useContext","SwitchLayoutGroupContext","useProjection","projectionId","_a","visualElement","ProjectionNodeConstructor","_b","layoutId","layout","drag","dragConstraints","layoutScroll","initialPromotionConfig","projection","getLatestValues","parent","setOptions","alwaysMeasureLayout","Boolean","scheduleRender","animationType"],"mappings":"AAAA,SAASA,WAAT,QAA4B,+BAA5B;AACA,SAASC,UAAT,QAA2B,OAA3B;AACA,SAASC,wBAAT,QAAyC,4CAAzC;;AAEA,SAASC,aAAT,CAAuBC,YAAvB,EAAqCC,EAArC,EAAyCC,aAAzC,EAAwDC,yBAAxD,EAAmF;AAC/E,MAAIC,EAAJ;;AACA,MAAIC,QAAQ,GAAGJ,EAAE,CAACI,QAAlB;AAAA,MAA4BC,MAAM,GAAGL,EAAE,CAACK,MAAxC;AAAA,MAAgDC,IAAI,GAAGN,EAAE,CAACM,IAA1D;AAAA,MAAgEC,eAAe,GAAGP,EAAE,CAACO,eAArF;AAAA,MAAsGC,YAAY,GAAGR,EAAE,CAACQ,YAAxH;AACA,MAAIC,sBAAsB,GAAGb,UAAU,CAACC,wBAAD,CAAvC;;AACA,MAAI,CAACK,yBAAD,IACA,CAACD,aADD,KAECA,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,aAAa,CAACS,UAF7E,CAAJ,EAE8F;AAC1F;AACH;;AACDT,EAAAA,aAAa,CAACS,UAAd,GAA2B,IAAIR,yBAAJ,CAA8BH,YAA9B,EAA4CE,aAAa,CAACU,eAAd,EAA5C,EAA6E,CAACR,EAAE,GAAGF,aAAa,CAACW,MAApB,MAAgC,IAAhC,IAAwCT,EAAE,KAAK,KAAK,CAApD,GAAwD,KAAK,CAA7D,GAAiEA,EAAE,CAACO,UAAjJ,CAA3B;AACAT,EAAAA,aAAa,CAACS,UAAd,CAAyBG,UAAzB,CAAoC;AAChCT,IAAAA,QAAQ,EAAEA,QADsB;AAEhCC,IAAAA,MAAM,EAAEA,MAFwB;AAGhCS,IAAAA,mBAAmB,EAAEC,OAAO,CAACT,IAAD,CAAP,IAAkBC,eAAe,IAAIZ,WAAW,CAACY,eAAD,CAHrC;AAIhCN,IAAAA,aAAa,EAAEA,aAJiB;AAKhCe,IAAAA,cAAc,EAAE,YAAY;AAAE,aAAOf,aAAa,CAACe,cAAd,EAAP;AAAwC,KALtC;;AAMhC;AACR;AACA;AACA;AACA;AACA;AACA;AACQC,IAAAA,aAAa,EAAE,OAAOZ,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsC,MAbrB;AAchCI,IAAAA,sBAAsB,EAAEA,sBAdQ;AAehCD,IAAAA,YAAY,EAAEA;AAfkB,GAApC;AAiBH;;AAED,SAASV,aAAT","sourcesContent":["import { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useContext } from 'react';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\n\nfunction useProjection(projectionId, _a, visualElement, ProjectionNodeConstructor) {\n    var _b;\n    var layoutId = _a.layoutId, layout = _a.layout, drag = _a.drag, dragConstraints = _a.dragConstraints, layoutScroll = _a.layoutScroll;\n    var initialPromotionConfig = useContext(SwitchLayoutGroupContext);\n    if (!ProjectionNodeConstructor ||\n        !visualElement ||\n        (visualElement === null || visualElement === void 0 ? void 0 : visualElement.projection)) {\n        return;\n    }\n    visualElement.projection = new ProjectionNodeConstructor(projectionId, visualElement.getLatestValues(), (_b = visualElement.parent) === null || _b === void 0 ? void 0 : _b.projection);\n    visualElement.projection.setOptions({\n        layoutId: layoutId,\n        layout: layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement: visualElement,\n        scheduleRender: function () { return visualElement.scheduleRender(); },\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialPromotionConfig,\n        layoutScroll: layoutScroll,\n    });\n}\n\nexport { useProjection };\n"]},"metadata":{},"sourceType":"module"}