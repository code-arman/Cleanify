{"ast":null,"code":"'use strict';\n\nvar AuthenticationRequest = require('./authentication-request'),\n    WebApiRequest = require('./webapi-request'),\n    HttpManager = require('./http-manager');\n\nfunction SpotifyWebApi(credentials) {\n  this._credentials = credentials || {};\n}\n\nSpotifyWebApi.prototype = {\n  setCredentials: function (credentials) {\n    for (var key in credentials) {\n      if (credentials.hasOwnProperty(key)) {\n        this._credentials[key] = credentials[key];\n      }\n    }\n  },\n  getCredentials: function () {\n    return this._credentials;\n  },\n  resetCredentials: function () {\n    this._credentials = null;\n  },\n  setClientId: function (clientId) {\n    this._setCredential('clientId', clientId);\n  },\n  setClientSecret: function (clientSecret) {\n    this._setCredential('clientSecret', clientSecret);\n  },\n  setAccessToken: function (accessToken) {\n    this._setCredential('accessToken', accessToken);\n  },\n  setRefreshToken: function (refreshToken) {\n    this._setCredential('refreshToken', refreshToken);\n  },\n  setRedirectURI: function (redirectUri) {\n    this._setCredential('redirectUri', redirectUri);\n  },\n  getRedirectURI: function () {\n    return this._getCredential('redirectUri');\n  },\n  getClientId: function () {\n    return this._getCredential('clientId');\n  },\n  getClientSecret: function () {\n    return this._getCredential('clientSecret');\n  },\n  getAccessToken: function () {\n    return this._getCredential('accessToken');\n  },\n  getRefreshToken: function () {\n    return this._getCredential('refreshToken');\n  },\n  resetClientId: function () {\n    this._resetCredential('clientId');\n  },\n  resetClientSecret: function () {\n    this._resetCredential('clientSecret');\n  },\n  resetAccessToken: function () {\n    this._resetCredential('accessToken');\n  },\n  resetRefreshToken: function () {\n    this._resetCredential('refreshToken');\n  },\n  resetRedirectURI: function () {\n    this._resetCredential('redirectUri');\n  },\n  _setCredential: function (credentialKey, value) {\n    this._credentials = this._credentials || {};\n    this._credentials[credentialKey] = value;\n  },\n  _getCredential: function (credentialKey) {\n    if (!this._credentials) {\n      return;\n    } else {\n      return this._credentials[credentialKey];\n    }\n  },\n  _resetCredential: function (credentialKey) {\n    if (!this._credentials) {\n      return;\n    } else {\n      this._credentials[credentialKey] = null;\n    }\n  },\n\n  /**\n   * Look up a track.\n   * @param {string} trackId The track's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getTrack('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the track. Not returned if a callback is given.\n   */\n  getTrack: function (trackId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/tracks/' + trackId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several tracks.\n   * @param {string[]} trackIds The IDs of the artists.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtists(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artists. Not returned if a callback is given.\n   */\n  getTracks: function (trackIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/tracks').withQueryParameters({\n      ids: trackIds.join(',')\n    }, options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up an album.\n   * @param {string} albumId The album's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbum('0sNOF9WDwhWunNAHPD3Baj').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the album. Not returned if a callback is given.\n   */\n  getAlbum: function (albumId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/albums/' + albumId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several albums.\n   * @param {string[]} albumIds The IDs of the albums.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbums(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the albums. Not returned if a callback is given.\n   */\n  getAlbums: function (albumIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/albums').withQueryParameters({\n      ids: albumIds.join(',')\n    }, options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up an artist.\n   * @param {string} artistId The artist's ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example api.getArtist('1u7kkVrr14iBvrpYnZILJR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artist. Not returned if a callback is given.\n   */\n  getArtist: function (artistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists/' + artistId).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several artists.\n   * @param {string[]} artistIds The IDs of the artists.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtists(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artists. Not returned if a callback is given.\n   */\n  getArtists: function (artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists').withQueryParameters({\n      ids: artistIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for music entities of certain types.\n   * @param {string} query The search query.\n   * @param {string[]} types An array of item types to search across.\n   * Valid types are: 'album', 'artist', 'playlist', 'track', 'show', and 'episode'.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example search('Abba', ['track', 'playlist'], { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  search: function (query, types, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/search/').withQueryParameters({\n      type: types.join(','),\n      q: query\n    }, options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for an album.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchAlbums('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchAlbums: function (query, options, callback) {\n    return this.search(query, ['album'], options, callback);\n  },\n\n  /**\n   * Search for an artist.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchArtists('David Bowie', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchArtists: function (query, options, callback) {\n    return this.search(query, ['artist'], options, callback);\n  },\n\n  /**\n   * Search for a track.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchTracks('Mr. Brightside', { limit : 3, offset : 2 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchTracks: function (query, options, callback) {\n    return this.search(query, ['track'], options, callback);\n  },\n\n  /**\n   * Search for playlists.\n   * @param {string} query The search query.\n   * @param {Object} options The possible options.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchPlaylists('workout', { limit : 1, offset : 0 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchPlaylists: function (query, options, callback) {\n    return this.search(query, ['playlist'], options, callback);\n  },\n\n  /**\n   * Get an artist's albums.\n   * @param {string} artistId The artist's ID.\n   * @options {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistAlbums('0oSGxfWSnnOXhD2fKuz2Gy', { album_type : 'album', country : 'GB', limit : 2, offset : 5 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the albums\n   *          for the given artist. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  getArtistAlbums: function (artistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists/' + artistId + '/albums').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the tracks of an album.\n   * @param albumId the album's ID.\n   * @options {Object} [options] The possible options, e.g. limit.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbumTracks('41MnTivkwTO3UUJ8DrqEJJ', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *                    tracks in the album. The result is paginated. If the promise is rejected.\n   *                    it contains an error object. Not returned if a callback is given.\n   */\n  getAlbumTracks: function (albumId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/albums/' + albumId + '/tracks').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get an artist's top tracks.\n   * @param {string} artistId The artist's ID.\n   * @param {string} country The country/territory where the tracks are most popular. (format: ISO 3166-1 alpha-2)\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistTopTracks('0oSGxfWSnnOXhD2fKuz2Gy', 'GB').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          artist's top tracks in the given country. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  getArtistTopTracks: function (artistId, country, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists/' + artistId + '/top-tracks').withQueryParameters({\n      country: country\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get related artists.\n   * @param {string} artistId The artist's ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistRelatedArtists('0oSGxfWSnnOXhD2fKuz2Gy').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          related artists. If the promise is rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getArtistRelatedArtists: function (artistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/artists/' + artistId + '/related-artists').build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get information about a user.\n   * @param userId The user ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getUser('thelinmichael').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the user. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getUser: function (userId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/users/' + encodeURIComponent(userId)).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get information about the user that has signed in (the current user).\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getMe().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the user. The amount of information\n   *          depends on the permissions given by the user. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getMe: function (callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me').build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a user's playlists.\n   * @param {string} userId An optional id of the user. If you know the Spotify URI it is easy\n   * to find the id (e.g. spotify:user:<here_is_the_id>). If not provided, the id of the user that granted\n   * the permissions will be used.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getUserPlaylists('thelinmichael').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of playlists. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getUserPlaylists: function (userId, options, callback) {\n    var path;\n\n    if (typeof userId === 'string') {\n      path = '/v1/users/' + encodeURIComponent(userId) + '/playlists';\n    } else if (typeof userId === 'object') {\n      callback = options;\n      options = userId;\n      path = '/v1/me/playlists';\n    }\n    /* undefined */\n    else {\n      path = '/v1/me/playlists';\n    }\n\n    return WebApiRequest.builder(this.getAccessToken()).withPath(path).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a playlist.\n   * @param {string} playlistId The playlist's ID.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getPlaylist('3EsfV6XzCHU8SPNdbnFogK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          the playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getPlaylist: function (playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get tracks in a playlist.\n   * @param {string} playlistId The playlist's ID.\n   * @param {Object} [options] Optional options, such as fields.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getPlaylistTracks('3ktAYNcRHpazJ9qecm3ptn').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object that containing\n   * the tracks in the playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getPlaylistTracks: function (playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Create a playlist.\n   * @param {string} [name] The name of the playlist.\n   * @param {Object} [options] The possible options, being description, collaborative and public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example createPlaylist('My playlist', {''description': 'My description', 'collaborative' : false, 'public': true}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing information about the\n   *          created playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  createPlaylist: function (name, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/playlists').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      name: name\n    }, options).build().execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Follow a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object} [options] The possible options, currently only public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  followPlaylist: function (playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/followers').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(options).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Unfollow a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  unfollowPlaylist: function (playlistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/followers').build().execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Change playlist details.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object} [options] The possible options, e.g. name, public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example changePlaylistDetails('3EsfV6XzCHU8SPNdbnFogK', {name: 'New name', public: true}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  changePlaylistDetails: function (playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId).withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(options).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Replace the image used to represent a specific playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {string} base64URI Base64 encoded JPEG image data, maximum payload size is 256 KB\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example uploadCustomPlaylistCoverImage('3EsfV6XzCHU8SPNdbnFogK', 'longbase64uri').then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  uploadCustomPlaylistCoverImage: function (playlistId, base64URI, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/images').withHeaders({\n      'Content-Type': 'image/jpeg'\n    }).withBodyParameters(base64URI).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add tracks to a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {string[]} tracks URIs of the tracks to add to the playlist.\n   * @param {Object} [options] Options, position being the only one.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example addTracksToPlaylist('3EsfV6XzCHU8SPNdbnFogK',\n              '[\"spotify:track:4iV5W9uYEdYUVa79Axb7Rh\", \"spotify:track:1301WleyT98MSxVHPZCA6M\"]').then(...)\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  addTracksToPlaylist: function (playlistId, tracks, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withQueryParameters(options).withBodyParameters({\n      uris: tracks\n    }).build().execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Remove tracks from a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object[]} tracks An array of objects containing a property called uri with the track URI (String), and\n   * an optional property called positions (int[]), e.g. { uri : \"spotify:track:491rM2JN8KvmV6p0oDDuJT\", positions : [0, 15] }\n   * @param {Object} options Options, snapshot_id being the only one.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  removeTracksFromPlaylist: function (playlistId, tracks, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      tracks: tracks\n    }, options).build().execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Remove tracks from a playlist by position instead of specifying the tracks' URIs.\n   * @param {string} playlistId The playlist's ID\n   * @param {int[]} positions The positions of the tracks in the playlist that should be removed\n   * @param {string} snapshot_id The snapshot ID, or version, of the playlist. Required\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  removeTracksFromPlaylistByPosition: function (playlistId, positions, snapshotId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      positions: positions,\n      snapshot_id: snapshotId\n    }).build().execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Replace tracks in a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object[]} uris An array of track URIs (strings)\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  replaceTracksInPlaylist: function (playlistId, uris, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      uris: uris\n    }).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Reorder tracks in a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {int} rangeStart The position of the first track to be reordered.\n   * @param {int} insertBefore The position where the tracks should be inserted.\n   * @param {Object} options Optional parameters, i.e. range_length and snapshot_id.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  reorderTracksInPlaylist: function (playlistId, rangeStart, insertBefore, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/playlists/' + playlistId + '/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      range_start: rangeStart,\n      insert_before: insertBefore\n    }, options).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Get audio features for a single track identified by its unique Spotify ID.\n   * @param {string} trackId The track ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioFeaturesForTrack('38P3Q4QcdjQALGF2Z92BmR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio features. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioFeaturesForTrack: function (trackId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/audio-features/' + trackId).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get audio analysis for a single track identified by its unique Spotify ID.\n   * @param {string} trackId The track ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioAnalysisForTrack('38P3Q4QcdjQALGF2Z92BmR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio analysis. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioAnalysisForTrack: function (trackId, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/audio-analysis/' + trackId).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get audio features for multiple tracks identified by their unique Spotify ID.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioFeaturesForTracks(['38P3Q4QcdjQALGF2Z92BmR', '2HO2bnoMrpnZUbUqiilLHi']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio features for the tracks. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioFeaturesForTracks: function (trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/audio-features').withQueryParameters({\n      ids: trackIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Create a playlist-style listening experience based on seed artists, tracks and genres.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getRecommendations({ min_energy: 0.4, seed_artists: ['6mfK6Q2tzLMEchAr0e9Uzu', '4DYFVNKZ1uixa6SQTvzQwJ'], min_popularity: 50 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of tracks and a list of seeds. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getRecommendations: function (options, callback) {\n    var _opts = {};\n    var optionsOfTypeArray = ['seed_artists', 'seed_genres', 'seed_tracks'];\n\n    for (var option in options) {\n      if (options.hasOwnProperty(option)) {\n        if (optionsOfTypeArray.indexOf(option) !== -1 && Object.prototype.toString.call(options[option]) === '[object Array]') {\n          _opts[option] = options[option].join(',');\n        } else {\n          _opts[option] = options[option];\n        }\n      }\n    }\n\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/recommendations').withQueryParameters(_opts).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a list of available genres seed parameter values for recommendations.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAvailableGenreSeeds().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of available genres to be used as seeds for recommendations.\n   *          If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAvailableGenreSeeds: function (callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/recommendations/available-genre-seeds').build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve the tracks that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist track objects. Not returned if a callback is given.\n   */\n  getMySavedTracks: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/tracks').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more tracks is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the track ID in the request.\n   * The boolean value of true indicates that the track is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedTracks: function (trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/tracks/contains').withQueryParameters({\n      ids: trackIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Remove a track from the authenticated user's Your Music library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedTracks: function (trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      ids: trackIds\n    }).build().execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add a track from the authenticated user's Your Music library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedTracks: function (trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/tracks').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      ids: trackIds\n    }).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Remove an album from the authenticated user's Your Music library.\n   * @param {string[]} albumIds The album IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedAlbums: function (albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/albums').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(albumIds).build().execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add an album from the authenticated user's Your Music library.\n   * @param {string[]} albumIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedAlbums: function (albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/albums').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(albumIds).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Retrieve the albums that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist album objects. Not returned if a callback is given.\n   */\n  getMySavedAlbums: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/albums').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more albums is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} albumIds The album IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the album ID in the request.\n   * The boolean value of true indicates that the album is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedAlbums: function (albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/albums/contains').withQueryParameters({\n      ids: albumIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's top artists based on calculated affinity.\n   * @param {Object} [options] Options, being time_range, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of artists,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyTopArtists: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/top/artists').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's top tracks based on calculated affinity.\n   * @param {Object} [options] Options, being time_range, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyTopTracks: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/top/tracks').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the Current User's Recently Played Tracks\n   * @param {Object} [options] Options, being type, after, limit, before.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of play history objects,\n   *          otherwise an error. Not returned if a callback is given. Note that the response will be empty\n   *          in case the user has enabled private session.\n   */\n  getMyRecentlyPlayedTracks: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/recently-played').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Add track or episode to device queue\n   * @param {string} [uri] uri of the track or episode to add\n   * @param {Object} [options] Options, being device_id.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  addToQueue: function (uri, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/queue').withQueryParameters({\n      uri: uri\n    }, options).build().execute(HttpManager.post, callback);\n  },\n\n  /** \n   * Get the Current User's Available Devices\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of device objects,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyDevices: function (callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/devices').build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the Current User's Currently Playing Track.\n   * @param {Object} [options] Options, being market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyCurrentPlayingTrack: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/currently-playing').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get Information About The User's Current Playback State\n   * @param {Object} [options] Options, being market and additional_types.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyCurrentPlaybackState: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Transfer a User's Playback\n   * @param {string[]} [deviceIds] An _array_ containing a device ID on which playback should be started/transferred. \n   * (NOTE: The API is currently only supporting a single device ID.)\n   * @param {Object} [options] Options, the only one being 'play'.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  transferMyPlayback: function (deviceIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters({\n      device_ids: deviceIds\n    }, options).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Starts o Resumes the Current User's Playback\n   * @param {Object} [options] Options, being device_id, context_uri, offset, uris, position_ms.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example play({context_uri: 'spotify:album:5ht7ItJgpBH7W6vJ5BqpPr'}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  play: function (options, callback) {\n    /*jshint camelcase: false */\n    var _options = options || {};\n\n    var queryParams = _options.device_id ? {\n      device_id: _options.device_id\n    } : null;\n    var postData = {};\n    ['context_uri', 'uris', 'offset', 'position_ms'].forEach(function (field) {\n      if (field in _options) {\n        postData[field] = _options[field];\n      }\n    });\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/play').withQueryParameters(queryParams).withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(postData).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Pauses the Current User's Playback\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example pause().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  pause: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/pause')\n    /*jshint camelcase: false */\n    .withQueryParameters(options && options.device_id ? {\n      device_id: options.device_id\n    } : null).withHeaders({\n      'Content-Type': 'application/json'\n    }).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Skip the Current User's Playback To Previous Track\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example skipToPrevious().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  skipToPrevious: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/previous').withQueryParameters(options && options.device_id ? {\n      device_id: options.device_id\n    } : null).build().execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Skip the Current User's Playback To Next Track\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example skipToNext().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  skipToNext: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/next').withQueryParameters(options && options.device_id ? {\n      device_id: options.device_id\n    } : null).build().execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Seeks to the given position in the user’s currently playing track.\n   *\n   * @param {number} positionMs The position in milliseconds to seek to. Must be a positive number.\n   * @param {Object} options Options, being device_id. If left empty will target the user's currently active device.\n   * @param {function(Object,Object)} callback An optional callback that receives 2 parameters. The first\n   * one is the error object (null if no error), and the second is the value if the request succeeded.\n   * @return {Object} Null if a callback is provided, a `Promise` object otherwise\n   */\n  seek: function (positionMs, options, callback) {\n    var params = {\n      /* jshint camelcase: false */\n      position_ms: positionMs\n    };\n\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/seek').withQueryParameters(params).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set Repeat Mode On The Current User's Playback\n   * @param {string} [state] State (track, context, or off)\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example setRepeat('context', {}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  setRepeat: function (state, options, callback) {\n    var params = {\n      state: state\n    };\n\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/repeat').withQueryParameters(params).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set Shuffle Mode On The Current User's Playback\n   * @param {boolean} [state] State \n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example setShuffle({state: 'false'}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  setShuffle: function (state, options, callback) {\n    var params = {\n      state: state\n    };\n\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/shuffle').withQueryParameters(params).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set the volume for the user’s current playback device.\n   * @param {number} volumePercent The volume to set. Must be a value from 0 to 100.\n   * @param {Object} options Options, being device_id. If left empty will target the user's currently active device.\n   * @param {function(Object,Object)} callback An optional callback that receives 2 parameters. The first\n   * one is the error object (null if no error), and the second is the value if the request succeeded.\n   * @return {Object} Null if a callback is provided, a `Promise` object otherwise\n   */\n  setVolume: function (volumePercent, options, callback) {\n    var params = {\n      /* jshint camelcase: false */\n      volume_percent: volumePercent\n    };\n\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/player/volume').withQueryParameters(params).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add the current user as a follower of one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to be followed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example followUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  followUsers: function (userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      ids: userIds.join(','),\n      type: 'user'\n    }).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add the current user as a follower of one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to be followed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example followArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  followArtists: function (artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      ids: artistIds.join(','),\n      type: 'artist'\n    }).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Remove the current user as a follower of one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to be unfollowed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example unfollowUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  unfollowUsers: function (userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      ids: userIds.join(','),\n      type: 'user'\n    }).build().execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Remove the current user as a follower of one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to be unfollowed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example unfollowArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  unfollowArtists: function (artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      ids: artistIds.join(','),\n      type: 'artist'\n    }).build().execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Check to see if the current user is following one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to check if are followed by the current user.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example isFollowingUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   *          of the returned array's elements correspond to the users IDs in the request.\n   *          The boolean value of true indicates that the user is following that user, otherwise is not.\n   *          Not returned if a callback is given.\n   */\n  isFollowingUsers: function (userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following/contains').withQueryParameters({\n      ids: userIds.join(','),\n      type: 'user'\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's followed artists.\n   * @param {Object} [options] Options, being after and limit.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * album objects. Not returned if a callback is given.\n   */\n  getFollowedArtists: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following').withQueryParameters({\n      type: 'artist'\n    }, options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if users are following a playlist.\n   * @param {string} userId The playlist's owner's user ID\n   * @param {string} playlistId The playlist's ID\n   * @param {String[]} User IDs of the following users\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an array of booleans. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  areFollowingPlaylist: function (userId, playlistId, followerIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/users/' + encodeURIComponent(userId) + '/playlists/' + playlistId + '/followers/contains').withQueryParameters({\n      ids: followerIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check to see if the current user is following one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to check if are followed by the current user.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example isFollowingArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   *          of the returned array's elements correspond to the artists IDs in the request.\n   *          The boolean value of true indicates that the user is following that artist, otherwise is not.\n   *          Not returned if a callback is given.\n   */\n  isFollowingArtists: function (artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/following/contains').withQueryParameters({\n      ids: artistIds.join(','),\n      type: 'artist'\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve new releases\n   * @param {Object} [options] Options, being country, limit and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * album objects. Not returned if a callback is given.\n   */\n  getNewReleases: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/new-releases').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve featured playlists\n   * @param {Object} [options] Options, being country, locale, timestamp, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * featured playlists. Not returned if a callback is given.\n   */\n  getFeaturedPlaylists: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/featured-playlists').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a list of categories used to tag items in Spotify (e.g. in the 'Browse' tab)\n   * @param {Object} [options] Options, being country, locale, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object of categories.\n   * Not returned if a callback is given.\n   */\n  getCategories: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/categories').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a category.\n   * @param {string} categoryId The id of the category to retrieve.\n   * @param {Object} [options] Options, being country, locale.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a category object.\n   * Not returned if a callback is given.\n   */\n  getCategory: function (categoryId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/categories/' + categoryId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve playlists for a category.\n   * @param {string} categoryId The id of the category to retrieve playlists for.\n   * @param {Object} [options] Options, being country, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to a paging object containing simple playlists.\n   * Not returned if a callback is given.\n   */\n  getPlaylistsForCategory: function (categoryId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/browse/categories/' + categoryId + '/playlists').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a show.\n   * @param {string} showId The show's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShow('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the show. Not returned if a callback is given.\n   */\n  getShow: function (showId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/shows/' + showId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several shows.\n   * @param {string[]} showIds The IDs of the shows.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShows(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the shows. Not returned if a callback is given.\n   */\n  getShows: function (showIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/shows').withQueryParameters({\n      ids: showIds.join(',')\n    }, options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more shows is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the show ID in the request.\n   * The boolean value of true indicates that the show is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedShows: function (showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/shows/contains').withQueryParameters({\n      ids: showIds.join(',')\n    }).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Remove an show from the authenticated user's Your Music library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedShows: function (showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/shows').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(showIds).build().execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add a show from the authenticated user's Your Music library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedShows: function (showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/shows').withHeaders({\n      'Content-Type': 'application/json'\n    }).withBodyParameters(showIds).build().execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Retrieve the shows that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist show objects. Not returned if a callback is given.\n   */\n  getMySavedShows: function (options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/me/shows').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the episodes of an show.\n   * @param showId the show's ID.\n   * @options {Object} [options] The possible options, being limit, offset, and market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShowEpisodes('41MnTivkwTO3UUJ8DrqEJJ', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *                    episodes in the album. The result is paginated. If the promise is rejected.\n   *                    it contains an error object. Not returned if a callback is given.\n   */\n  getShowEpisodes: function (showId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/shows/' + showId + '/episodes').withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for a show.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchShows('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchShows: function (query, options, callback) {\n    return this.search(query, ['show'], options, callback);\n  },\n\n  /**\n   * Search for an episode.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchEpisodes('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchEpisodes: function (query, options, callback) {\n    return this.search(query, ['episode'], options, callback);\n  },\n\n  /**\n    * Look up an episode.\n    * @param {string} episodeId The episode's ID.\n    * @param {Object} [options] The possible options, currently only market.\n    * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n    * @example getEpisode('3Qm86XLflmIXVm1wcwkgDK').then(...)\n    * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n    *          about the episode. Not returned if a callback is given.\n    */\n  getEpisode: function (episodeId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/episodes/' + episodeId).withQueryParameters(options).build().execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several episodes.\n   * @param {string[]} episodeIds The IDs of the episodes.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getEpisodes(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the episodes. Not returned if a callback is given.\n   */\n  getEpisodes: function (episodeIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken()).withPath('/v1/episodes').withQueryParameters({\n      ids: episodeIds.join(',')\n    }, options).build().execute(HttpManager.get, callback);\n  }\n};\n\nSpotifyWebApi._addMethods = function (methods) {\n  for (var i in methods) {\n    if (methods.hasOwnProperty(i)) {\n      this.prototype[i] = methods[i];\n    }\n  }\n};\n\nmodule.exports = SpotifyWebApi;","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/spotify-web-api-node/src/spotify-web-api.js"],"names":["AuthenticationRequest","require","WebApiRequest","HttpManager","SpotifyWebApi","credentials","_credentials","prototype","setCredentials","key","hasOwnProperty","getCredentials","resetCredentials","setClientId","clientId","_setCredential","setClientSecret","clientSecret","setAccessToken","accessToken","setRefreshToken","refreshToken","setRedirectURI","redirectUri","getRedirectURI","_getCredential","getClientId","getClientSecret","getAccessToken","getRefreshToken","resetClientId","_resetCredential","resetClientSecret","resetAccessToken","resetRefreshToken","resetRedirectURI","credentialKey","value","getTrack","trackId","options","callback","builder","withPath","withQueryParameters","build","execute","get","getTracks","trackIds","ids","join","getAlbum","albumId","getAlbums","albumIds","getArtist","artistId","getArtists","artistIds","search","query","types","type","q","searchAlbums","searchArtists","searchTracks","searchPlaylists","getArtistAlbums","getAlbumTracks","getArtistTopTracks","country","getArtistRelatedArtists","getUser","userId","encodeURIComponent","getMe","getUserPlaylists","path","getPlaylist","playlistId","getPlaylistTracks","createPlaylist","name","withHeaders","withBodyParameters","post","followPlaylist","put","unfollowPlaylist","del","changePlaylistDetails","uploadCustomPlaylistCoverImage","base64URI","addTracksToPlaylist","tracks","uris","removeTracksFromPlaylist","removeTracksFromPlaylistByPosition","positions","snapshotId","snapshot_id","replaceTracksInPlaylist","reorderTracksInPlaylist","rangeStart","insertBefore","range_start","insert_before","getAudioFeaturesForTrack","getAudioAnalysisForTrack","getAudioFeaturesForTracks","getRecommendations","_opts","optionsOfTypeArray","option","indexOf","Object","toString","call","getAvailableGenreSeeds","getMySavedTracks","containsMySavedTracks","removeFromMySavedTracks","addToMySavedTracks","removeFromMySavedAlbums","addToMySavedAlbums","getMySavedAlbums","containsMySavedAlbums","getMyTopArtists","getMyTopTracks","getMyRecentlyPlayedTracks","addToQueue","uri","getMyDevices","getMyCurrentPlayingTrack","getMyCurrentPlaybackState","transferMyPlayback","deviceIds","device_ids","play","_options","queryParams","device_id","postData","forEach","field","pause","skipToPrevious","skipToNext","seek","positionMs","params","position_ms","setRepeat","state","setShuffle","setVolume","volumePercent","volume_percent","followUsers","userIds","followArtists","unfollowUsers","unfollowArtists","isFollowingUsers","getFollowedArtists","areFollowingPlaylist","followerIds","isFollowingArtists","getNewReleases","getFeaturedPlaylists","getCategories","getCategory","categoryId","getPlaylistsForCategory","getShow","showId","getShows","showIds","containsMySavedShows","removeFromMySavedShows","addToMySavedShows","getMySavedShows","getShowEpisodes","searchShows","searchEpisodes","getEpisode","episodeId","getEpisodes","episodeIds","_addMethods","methods","i","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar AuthenticationRequest = require('./authentication-request'),\n  WebApiRequest = require('./webapi-request'),\n  HttpManager = require('./http-manager');\n\nfunction SpotifyWebApi(credentials) {\n  this._credentials = credentials || {};\n}\n\nSpotifyWebApi.prototype = {\n  setCredentials: function(credentials) {\n    for (var key in credentials) {\n      if (credentials.hasOwnProperty(key)) {\n        this._credentials[key] = credentials[key];\n      }\n    }\n  },\n\n  getCredentials: function() {\n    return this._credentials;\n  },\n\n  resetCredentials: function() {\n    this._credentials = null;\n  },\n\n  setClientId: function(clientId) {\n    this._setCredential('clientId', clientId);\n  },\n\n  setClientSecret: function(clientSecret) {\n    this._setCredential('clientSecret', clientSecret);\n  },\n\n  setAccessToken: function(accessToken) {\n    this._setCredential('accessToken', accessToken);\n  },\n\n  setRefreshToken: function(refreshToken) {\n    this._setCredential('refreshToken', refreshToken);\n  },\n\n  setRedirectURI: function(redirectUri) {\n    this._setCredential('redirectUri', redirectUri);\n  },\n\n  getRedirectURI: function() {\n    return this._getCredential('redirectUri');\n  },\n\n  getClientId: function() {\n    return this._getCredential('clientId');\n  },\n\n  getClientSecret: function() {\n    return this._getCredential('clientSecret');\n  },\n\n  getAccessToken: function() {\n    return this._getCredential('accessToken');\n  },\n\n  getRefreshToken: function() {\n    return this._getCredential('refreshToken');\n  },\n\n  resetClientId: function() {\n    this._resetCredential('clientId');\n  },\n\n  resetClientSecret: function() {\n    this._resetCredential('clientSecret');\n  },\n\n  resetAccessToken: function() {\n    this._resetCredential('accessToken');\n  },\n\n  resetRefreshToken: function() {\n    this._resetCredential('refreshToken');\n  },\n\n  resetRedirectURI: function() {\n    this._resetCredential('redirectUri');\n  },\n\n  _setCredential: function(credentialKey, value) {\n    this._credentials = this._credentials || {};\n    this._credentials[credentialKey] = value;\n  },\n\n  _getCredential: function(credentialKey) {\n    if (!this._credentials) {\n      return;\n    } else {\n      return this._credentials[credentialKey];\n    }\n  },\n\n  _resetCredential: function(credentialKey) {\n    if (!this._credentials) {\n      return;\n    } else {\n      this._credentials[credentialKey] = null;\n    }\n  },\n\n  /**\n   * Look up a track.\n   * @param {string} trackId The track's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getTrack('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the track. Not returned if a callback is given.\n   */\n  getTrack: function(trackId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/tracks/' + trackId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several tracks.\n   * @param {string[]} trackIds The IDs of the artists.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtists(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artists. Not returned if a callback is given.\n   */\n  getTracks: function(trackIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/tracks')\n      .withQueryParameters(\n        {\n          ids: trackIds.join(',')\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up an album.\n   * @param {string} albumId The album's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbum('0sNOF9WDwhWunNAHPD3Baj').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the album. Not returned if a callback is given.\n   */\n  getAlbum: function(albumId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/albums/' + albumId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several albums.\n   * @param {string[]} albumIds The IDs of the albums.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbums(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the albums. Not returned if a callback is given.\n   */\n  getAlbums: function(albumIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/albums')\n      .withQueryParameters(\n        {\n          ids: albumIds.join(',')\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up an artist.\n   * @param {string} artistId The artist's ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example api.getArtist('1u7kkVrr14iBvrpYnZILJR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artist. Not returned if a callback is given.\n   */\n  getArtist: function(artistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists/' + artistId)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several artists.\n   * @param {string[]} artistIds The IDs of the artists.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtists(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artists. Not returned if a callback is given.\n   */\n  getArtists: function(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists')\n      .withQueryParameters({\n        ids: artistIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for music entities of certain types.\n   * @param {string} query The search query.\n   * @param {string[]} types An array of item types to search across.\n   * Valid types are: 'album', 'artist', 'playlist', 'track', 'show', and 'episode'.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example search('Abba', ['track', 'playlist'], { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  search: function(query, types, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/search/')\n      .withQueryParameters(\n        {\n          type: types.join(','),\n          q: query\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for an album.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchAlbums('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchAlbums: function(query, options, callback) {\n    return this.search(query, ['album'], options, callback);\n  },\n\n  /**\n   * Search for an artist.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchArtists('David Bowie', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchArtists: function(query, options, callback) {\n    return this.search(query, ['artist'], options, callback);\n  },\n\n  /**\n   * Search for a track.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchTracks('Mr. Brightside', { limit : 3, offset : 2 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchTracks: function(query, options, callback) {\n    return this.search(query, ['track'], options, callback);\n  },\n\n  /**\n   * Search for playlists.\n   * @param {string} query The search query.\n   * @param {Object} options The possible options.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchPlaylists('workout', { limit : 1, offset : 0 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchPlaylists: function(query, options, callback) {\n    return this.search(query, ['playlist'], options, callback);\n  },\n\n  /**\n   * Get an artist's albums.\n   * @param {string} artistId The artist's ID.\n   * @options {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistAlbums('0oSGxfWSnnOXhD2fKuz2Gy', { album_type : 'album', country : 'GB', limit : 2, offset : 5 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the albums\n   *          for the given artist. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  getArtistAlbums: function(artistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists/' + artistId + '/albums')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the tracks of an album.\n   * @param albumId the album's ID.\n   * @options {Object} [options] The possible options, e.g. limit.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbumTracks('41MnTivkwTO3UUJ8DrqEJJ', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *                    tracks in the album. The result is paginated. If the promise is rejected.\n   *                    it contains an error object. Not returned if a callback is given.\n   */\n  getAlbumTracks: function(albumId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/albums/' + albumId + '/tracks')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get an artist's top tracks.\n   * @param {string} artistId The artist's ID.\n   * @param {string} country The country/territory where the tracks are most popular. (format: ISO 3166-1 alpha-2)\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistTopTracks('0oSGxfWSnnOXhD2fKuz2Gy', 'GB').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          artist's top tracks in the given country. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  getArtistTopTracks: function(artistId, country, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists/' + artistId + '/top-tracks')\n      .withQueryParameters({\n        country: country\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get related artists.\n   * @param {string} artistId The artist's ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistRelatedArtists('0oSGxfWSnnOXhD2fKuz2Gy').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          related artists. If the promise is rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getArtistRelatedArtists: function(artistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists/' + artistId + '/related-artists')\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get information about a user.\n   * @param userId The user ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getUser('thelinmichael').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the user. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getUser: function(userId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/users/' + encodeURIComponent(userId))\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get information about the user that has signed in (the current user).\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getMe().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the user. The amount of information\n   *          depends on the permissions given by the user. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getMe: function(callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me')\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a user's playlists.\n   * @param {string} userId An optional id of the user. If you know the Spotify URI it is easy\n   * to find the id (e.g. spotify:user:<here_is_the_id>). If not provided, the id of the user that granted\n   * the permissions will be used.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getUserPlaylists('thelinmichael').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of playlists. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getUserPlaylists: function(userId, options, callback) {\n    var path;\n    if (typeof userId === 'string') {\n      path = '/v1/users/' + encodeURIComponent(userId) + '/playlists';\n    } else if (typeof userId === 'object') {\n      callback = options;\n      options = userId;\n      path = '/v1/me/playlists';\n    } /* undefined */ else {\n      path = '/v1/me/playlists';\n    }\n\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath(path)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a playlist.\n   * @param {string} playlistId The playlist's ID.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getPlaylist('3EsfV6XzCHU8SPNdbnFogK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          the playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getPlaylist: function(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get tracks in a playlist.\n   * @param {string} playlistId The playlist's ID.\n   * @param {Object} [options] Optional options, such as fields.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getPlaylistTracks('3ktAYNcRHpazJ9qecm3ptn').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object that containing\n   * the tracks in the playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getPlaylistTracks: function(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Create a playlist.\n   * @param {string} [name] The name of the playlist.\n   * @param {Object} [options] The possible options, being description, collaborative and public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example createPlaylist('My playlist', {''description': 'My description', 'collaborative' : false, 'public': true}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing information about the\n   *          created playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  createPlaylist: function(name, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/playlists')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({\n        name : name,\n      }, options)\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Follow a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object} [options] The possible options, currently only public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  followPlaylist: function(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/followers')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(options)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Unfollow a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  unfollowPlaylist: function(playlistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/followers')\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Change playlist details.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object} [options] The possible options, e.g. name, public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example changePlaylistDetails('3EsfV6XzCHU8SPNdbnFogK', {name: 'New name', public: true}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  changePlaylistDetails: function(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId)\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(options)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Replace the image used to represent a specific playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {string} base64URI Base64 encoded JPEG image data, maximum payload size is 256 KB\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example uploadCustomPlaylistCoverImage('3EsfV6XzCHU8SPNdbnFogK', 'longbase64uri').then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  uploadCustomPlaylistCoverImage: function(playlistId, base64URI, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/images')\n      .withHeaders({ 'Content-Type': 'image/jpeg' })\n      .withBodyParameters(base64URI)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add tracks to a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {string[]} tracks URIs of the tracks to add to the playlist.\n   * @param {Object} [options] Options, position being the only one.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example addTracksToPlaylist('3EsfV6XzCHU8SPNdbnFogK',\n              '[\"spotify:track:4iV5W9uYEdYUVa79Axb7Rh\", \"spotify:track:1301WleyT98MSxVHPZCA6M\"]').then(...)\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  addTracksToPlaylist: function(playlistId, tracks, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withQueryParameters(options)\n      .withBodyParameters({\n        uris: tracks\n      })\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Remove tracks from a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object[]} tracks An array of objects containing a property called uri with the track URI (String), and\n   * an optional property called positions (int[]), e.g. { uri : \"spotify:track:491rM2JN8KvmV6p0oDDuJT\", positions : [0, 15] }\n   * @param {Object} options Options, snapshot_id being the only one.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  removeTracksFromPlaylist: function(playlistId, tracks, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(\n        {\n          tracks: tracks\n        }, \n        options\n      )\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Remove tracks from a playlist by position instead of specifying the tracks' URIs.\n   * @param {string} playlistId The playlist's ID\n   * @param {int[]} positions The positions of the tracks in the playlist that should be removed\n   * @param {string} snapshot_id The snapshot ID, or version, of the playlist. Required\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  removeTracksFromPlaylistByPosition: function(\n    playlistId,\n    positions,\n    snapshotId,\n    callback\n  ) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({\n        positions: positions,\n        snapshot_id: snapshotId\n      })\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Replace tracks in a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object[]} uris An array of track URIs (strings)\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  replaceTracksInPlaylist: function(playlistId, uris, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({\n        uris: uris\n      })\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Reorder tracks in a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {int} rangeStart The position of the first track to be reordered.\n   * @param {int} insertBefore The position where the tracks should be inserted.\n   * @param {Object} options Optional parameters, i.e. range_length and snapshot_id.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  reorderTracksInPlaylist: function(\n    playlistId,\n    rangeStart,\n    insertBefore,\n    options,\n    callback\n  ) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(\n        {\n          range_start: rangeStart,\n          insert_before: insertBefore\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Get audio features for a single track identified by its unique Spotify ID.\n   * @param {string} trackId The track ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioFeaturesForTrack('38P3Q4QcdjQALGF2Z92BmR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio features. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioFeaturesForTrack: function(trackId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/audio-features/' + trackId)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get audio analysis for a single track identified by its unique Spotify ID.\n   * @param {string} trackId The track ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioAnalysisForTrack('38P3Q4QcdjQALGF2Z92BmR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio analysis. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioAnalysisForTrack: function(trackId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/audio-analysis/' + trackId)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get audio features for multiple tracks identified by their unique Spotify ID.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioFeaturesForTracks(['38P3Q4QcdjQALGF2Z92BmR', '2HO2bnoMrpnZUbUqiilLHi']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio features for the tracks. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioFeaturesForTracks: function(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/audio-features')\n      .withQueryParameters({\n        ids: trackIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Create a playlist-style listening experience based on seed artists, tracks and genres.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getRecommendations({ min_energy: 0.4, seed_artists: ['6mfK6Q2tzLMEchAr0e9Uzu', '4DYFVNKZ1uixa6SQTvzQwJ'], min_popularity: 50 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of tracks and a list of seeds. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getRecommendations: function(options, callback) {\n    var _opts = {};\n    var optionsOfTypeArray = ['seed_artists', 'seed_genres', 'seed_tracks'];\n    for (var option in options) {\n      if (options.hasOwnProperty(option)) {\n        if (\n          optionsOfTypeArray.indexOf(option) !== -1 &&\n          Object.prototype.toString.call(options[option]) === '[object Array]'\n        ) {\n          _opts[option] = options[option].join(',');\n        } else {\n          _opts[option] = options[option];\n        }\n      }\n    }\n\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/recommendations')\n      .withQueryParameters(_opts)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a list of available genres seed parameter values for recommendations.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAvailableGenreSeeds().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of available genres to be used as seeds for recommendations.\n   *          If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAvailableGenreSeeds: function(callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/recommendations/available-genre-seeds')\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve the tracks that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist track objects. Not returned if a callback is given.\n   */\n  getMySavedTracks: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/tracks')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more tracks is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the track ID in the request.\n   * The boolean value of true indicates that the track is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedTracks: function(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/tracks/contains')\n      .withQueryParameters({\n        ids: trackIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Remove a track from the authenticated user's Your Music library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedTracks: function(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({ ids: trackIds })\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add a track from the authenticated user's Your Music library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedTracks: function(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({ ids: trackIds })\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Remove an album from the authenticated user's Your Music library.\n   * @param {string[]} albumIds The album IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedAlbums: function(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/albums')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(albumIds)\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add an album from the authenticated user's Your Music library.\n   * @param {string[]} albumIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedAlbums: function(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/albums')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(albumIds)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Retrieve the albums that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist album objects. Not returned if a callback is given.\n   */\n  getMySavedAlbums: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/albums')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more albums is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} albumIds The album IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the album ID in the request.\n   * The boolean value of true indicates that the album is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedAlbums: function(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/albums/contains')\n      .withQueryParameters({\n        ids: albumIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's top artists based on calculated affinity.\n   * @param {Object} [options] Options, being time_range, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of artists,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyTopArtists: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/top/artists')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's top tracks based on calculated affinity.\n   * @param {Object} [options] Options, being time_range, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyTopTracks: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/top/tracks')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the Current User's Recently Played Tracks\n   * @param {Object} [options] Options, being type, after, limit, before.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of play history objects,\n   *          otherwise an error. Not returned if a callback is given. Note that the response will be empty\n   *          in case the user has enabled private session.\n   */\n  getMyRecentlyPlayedTracks: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/recently-played')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Add track or episode to device queue\n   * @param {string} [uri] uri of the track or episode to add\n   * @param {Object} [options] Options, being device_id.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  addToQueue: function(uri, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/queue')\n      .withQueryParameters(\n        {\n          uri: uri\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n\n  /** \n   * Get the Current User's Available Devices\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of device objects,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyDevices: function(callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/devices')\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the Current User's Currently Playing Track.\n   * @param {Object} [options] Options, being market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyCurrentPlayingTrack: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/currently-playing')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get Information About The User's Current Playback State\n   * @param {Object} [options] Options, being market and additional_types.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyCurrentPlaybackState: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Transfer a User's Playback\n   * @param {string[]} [deviceIds] An _array_ containing a device ID on which playback should be started/transferred. \n   * (NOTE: The API is currently only supporting a single device ID.)\n   * @param {Object} [options] Options, the only one being 'play'.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  transferMyPlayback: function(deviceIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(\n        {\n          device_ids: deviceIds,\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Starts o Resumes the Current User's Playback\n   * @param {Object} [options] Options, being device_id, context_uri, offset, uris, position_ms.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example play({context_uri: 'spotify:album:5ht7ItJgpBH7W6vJ5BqpPr'}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  play: function(options, callback) {\n    /*jshint camelcase: false */\n    var _options = options || {};\n    var queryParams = _options.device_id\n      ? { device_id: _options.device_id }\n      : null;\n    var postData = {};\n    ['context_uri', 'uris', 'offset', 'position_ms'].forEach(function(field) {\n      if (field in _options) {\n        postData[field] = _options[field];\n      }\n    });\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/play')\n      .withQueryParameters(queryParams)\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(postData)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Pauses the Current User's Playback\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example pause().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  pause: function(options, callback) {\n    return (\n      WebApiRequest.builder(this.getAccessToken())\n        .withPath('/v1/me/player/pause')\n        /*jshint camelcase: false */\n        .withQueryParameters(\n          options && options.device_id ? { device_id: options.device_id } : null\n        )\n        .withHeaders({ 'Content-Type': 'application/json' })\n        .build()\n        .execute(HttpManager.put, callback)\n    );\n  },\n\n  /**\n   * Skip the Current User's Playback To Previous Track\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example skipToPrevious().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  skipToPrevious: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/previous')\n      .withQueryParameters(\n        options && options.device_id ? { device_id: options.device_id } : null\n      )\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Skip the Current User's Playback To Next Track\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example skipToNext().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  skipToNext: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/next')\n      .withQueryParameters(\n        options && options.device_id ? { device_id: options.device_id } : null\n      )\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Seeks to the given position in the user’s currently playing track.\n   *\n   * @param {number} positionMs The position in milliseconds to seek to. Must be a positive number.\n   * @param {Object} options Options, being device_id. If left empty will target the user's currently active device.\n   * @param {function(Object,Object)} callback An optional callback that receives 2 parameters. The first\n   * one is the error object (null if no error), and the second is the value if the request succeeded.\n   * @return {Object} Null if a callback is provided, a `Promise` object otherwise\n   */\n  seek: function(positionMs, options, callback) {\n    var params = {\n      /* jshint camelcase: false */\n      position_ms: positionMs\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/seek')\n      .withQueryParameters(params)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set Repeat Mode On The Current User's Playback\n   * @param {string} [state] State (track, context, or off)\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example setRepeat('context', {}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  setRepeat: function(state, options, callback) {\n    var params = {\n      state: state\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/repeat')\n      .withQueryParameters(params)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set Shuffle Mode On The Current User's Playback\n   * @param {boolean} [state] State \n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example setShuffle({state: 'false'}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  setShuffle: function(state, options, callback) {\n    var params = {\n      state: state\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/shuffle')\n      .withQueryParameters(params)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set the volume for the user’s current playback device.\n   * @param {number} volumePercent The volume to set. Must be a value from 0 to 100.\n   * @param {Object} options Options, being device_id. If left empty will target the user's currently active device.\n   * @param {function(Object,Object)} callback An optional callback that receives 2 parameters. The first\n   * one is the error object (null if no error), and the second is the value if the request succeeded.\n   * @return {Object} Null if a callback is provided, a `Promise` object otherwise\n   */\n  setVolume: function(volumePercent, options, callback) {\n    var params = {\n      /* jshint camelcase: false */\n      volume_percent: volumePercent\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/volume')\n      .withQueryParameters(params)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add the current user as a follower of one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to be followed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example followUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  followUsers: function(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters({\n        ids: userIds.join(','),\n        type: 'user'\n      })\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add the current user as a follower of one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to be followed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example followArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  followArtists: function(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters({\n        ids: artistIds.join(','),\n        type: 'artist'\n      })\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Remove the current user as a follower of one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to be unfollowed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example unfollowUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  unfollowUsers: function(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters({\n        ids: userIds.join(','),\n        type: 'user'\n      })\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Remove the current user as a follower of one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to be unfollowed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example unfollowArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  unfollowArtists: function(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters({\n        ids: artistIds.join(','),\n        type: 'artist'\n      })\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Check to see if the current user is following one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to check if are followed by the current user.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example isFollowingUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   *          of the returned array's elements correspond to the users IDs in the request.\n   *          The boolean value of true indicates that the user is following that user, otherwise is not.\n   *          Not returned if a callback is given.\n   */\n  isFollowingUsers: function(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following/contains')\n      .withQueryParameters({\n        ids: userIds.join(','),\n        type: 'user'\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's followed artists.\n   * @param {Object} [options] Options, being after and limit.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * album objects. Not returned if a callback is given.\n   */\n  getFollowedArtists: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters(\n        {\n          type: 'artist'\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if users are following a playlist.\n   * @param {string} userId The playlist's owner's user ID\n   * @param {string} playlistId The playlist's ID\n   * @param {String[]} User IDs of the following users\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an array of booleans. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  areFollowingPlaylist: function(userId, playlistId, followerIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath(\n        '/v1/users/' +\n          encodeURIComponent(userId) +\n          '/playlists/' +\n          playlistId +\n          '/followers/contains'\n      )\n      .withQueryParameters({\n        ids: followerIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check to see if the current user is following one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to check if are followed by the current user.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example isFollowingArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   *          of the returned array's elements correspond to the artists IDs in the request.\n   *          The boolean value of true indicates that the user is following that artist, otherwise is not.\n   *          Not returned if a callback is given.\n   */\n  isFollowingArtists: function(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following/contains')\n      .withQueryParameters({\n        ids: artistIds.join(','),\n        type: 'artist'\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve new releases\n   * @param {Object} [options] Options, being country, limit and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * album objects. Not returned if a callback is given.\n   */\n  getNewReleases: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/new-releases')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve featured playlists\n   * @param {Object} [options] Options, being country, locale, timestamp, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * featured playlists. Not returned if a callback is given.\n   */\n  getFeaturedPlaylists: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/featured-playlists')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a list of categories used to tag items in Spotify (e.g. in the 'Browse' tab)\n   * @param {Object} [options] Options, being country, locale, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object of categories.\n   * Not returned if a callback is given.\n   */\n  getCategories: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/categories')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a category.\n   * @param {string} categoryId The id of the category to retrieve.\n   * @param {Object} [options] Options, being country, locale.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a category object.\n   * Not returned if a callback is given.\n   */\n  getCategory: function(categoryId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/categories/' + categoryId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve playlists for a category.\n   * @param {string} categoryId The id of the category to retrieve playlists for.\n   * @param {Object} [options] Options, being country, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to a paging object containing simple playlists.\n   * Not returned if a callback is given.\n   */\n  getPlaylistsForCategory: function(categoryId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/categories/' + categoryId + '/playlists')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a show.\n   * @param {string} showId The show's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShow('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the show. Not returned if a callback is given.\n   */\n  getShow: function(showId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n    .withPath('/v1/shows/' + showId)\n    .withQueryParameters(options)\n    .build()\n    .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several shows.\n   * @param {string[]} showIds The IDs of the shows.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShows(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the shows. Not returned if a callback is given.\n   */\n  getShows: function(showIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/shows')\n      .withQueryParameters(\n        {\n          ids: showIds.join(',')\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more shows is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the show ID in the request.\n   * The boolean value of true indicates that the show is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedShows: function(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/shows/contains')\n      .withQueryParameters({\n        ids: showIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Remove an show from the authenticated user's Your Music library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedShows: function(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/shows')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(showIds)\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add a show from the authenticated user's Your Music library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedShows: function(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/shows')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(showIds)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Retrieve the shows that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist show objects. Not returned if a callback is given.\n   */\n  getMySavedShows: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/shows')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the episodes of an show.\n   * @param showId the show's ID.\n   * @options {Object} [options] The possible options, being limit, offset, and market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShowEpisodes('41MnTivkwTO3UUJ8DrqEJJ', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *                    episodes in the album. The result is paginated. If the promise is rejected.\n   *                    it contains an error object. Not returned if a callback is given.\n   */\n  getShowEpisodes: function(showId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/shows/' + showId + '/episodes')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for a show.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchShows('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchShows: function(query, options, callback) {\n    return this.search(query, ['show'], options, callback);\n  },\n\n  /**\n   * Search for an episode.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchEpisodes('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchEpisodes: function(query, options, callback) {\n    return this.search(query, ['episode'], options, callback);\n  },\n\n /**\n   * Look up an episode.\n   * @param {string} episodeId The episode's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getEpisode('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the episode. Not returned if a callback is given.\n   */\n  getEpisode: function(episodeId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/episodes/' + episodeId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several episodes.\n   * @param {string[]} episodeIds The IDs of the episodes.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getEpisodes(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the episodes. Not returned if a callback is given.\n   */\n  getEpisodes: function(episodeIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/episodes')\n      .withQueryParameters(\n        {\n          ids: episodeIds.join(',')\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n};\n\nSpotifyWebApi._addMethods = function(methods) {\n  for (var i in methods) {\n    if (methods.hasOwnProperty(i)) {\n      this.prototype[i] = methods[i];\n    }\n  }\n};\n\nmodule.exports = SpotifyWebApi;\n"]},"metadata":{},"sourceType":"script"}