{"ast":null,"code":"import { animate } from './index.mjs';\nimport { velocityPerSecond } from '../utils/velocity-per-second.mjs';\nimport { getFrameData } from 'framesync';\n\nfunction inertia(_ref) {\n  let {\n    from = 0,\n    velocity = 0,\n    min,\n    max,\n    power = 0.8,\n    timeConstant = 750,\n    bounceStiffness = 500,\n    bounceDamping = 10,\n    restDelta = 1,\n    modifyTarget,\n    driver,\n    onUpdate,\n    onComplete,\n    onStop\n  } = _ref;\n  let currentAnimation;\n\n  function isOutOfBounds(v) {\n    return min !== undefined && v < min || max !== undefined && v > max;\n  }\n\n  function boundaryNearest(v) {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n\n  function startAnimation(options) {\n    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    currentAnimation = animate(Object.assign(Object.assign({}, options), {\n      driver,\n      onUpdate: v => {\n        var _a;\n\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n      },\n      onComplete,\n      onStop\n    }));\n  }\n\n  function startSpring(options) {\n    startAnimation(Object.assign({\n      type: \"spring\",\n      stiffness: bounceStiffness,\n      damping: bounceDamping,\n      restDelta\n    }, options));\n  }\n\n  if (isOutOfBounds(from)) {\n    startSpring({\n      from,\n      velocity,\n      to: boundaryNearest(from)\n    });\n  } else {\n    let target = power * velocity + from;\n    if (typeof modifyTarget !== \"undefined\") target = modifyTarget(target);\n    const boundary = boundaryNearest(target);\n    const heading = boundary === min ? -1 : 1;\n    let prev;\n    let current;\n\n    const checkBoundary = v => {\n      prev = current;\n      current = v;\n      velocity = velocityPerSecond(v - prev, getFrameData().delta);\n\n      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n        startSpring({\n          from: v,\n          to: boundary,\n          velocity\n        });\n      }\n    };\n\n    startAnimation({\n      type: \"decay\",\n      from,\n      velocity,\n      timeConstant,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : undefined\n    });\n  }\n\n  return {\n    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n  };\n}\n\nexport { inertia };","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/popmotion/dist/es/animations/inertia.mjs"],"names":["animate","velocityPerSecond","getFrameData","inertia","from","velocity","min","max","power","timeConstant","bounceStiffness","bounceDamping","restDelta","modifyTarget","driver","onUpdate","onComplete","onStop","currentAnimation","isOutOfBounds","v","undefined","boundaryNearest","Math","abs","startAnimation","options","stop","Object","assign","_a","call","startSpring","type","stiffness","damping","to","target","boundary","heading","prev","current","checkBoundary","delta"],"mappings":"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","sourcesContent":["import { animate } from './index.mjs';\nimport { velocityPerSecond } from '../utils/velocity-per-second.mjs';\nimport { getFrameData } from 'framesync';\n\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop, }) {\n    let currentAnimation;\n    function isOutOfBounds(v) {\n        return (min !== undefined && v < min) || (max !== undefined && v > max);\n    }\n    function boundaryNearest(v) {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n        currentAnimation = animate(Object.assign(Object.assign({}, options), { driver, onUpdate: (v) => {\n                var _a;\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n            }, onComplete,\n            onStop }));\n    }\n    function startSpring(options) {\n        startAnimation(Object.assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n    }\n    if (isOutOfBounds(from)) {\n        startSpring({ from, velocity, to: boundaryNearest(from) });\n    }\n    else {\n        let target = power * velocity + from;\n        if (typeof modifyTarget !== \"undefined\")\n            target = modifyTarget(target);\n        const boundary = boundaryNearest(target);\n        const heading = boundary === min ? -1 : 1;\n        let prev;\n        let current;\n        const checkBoundary = (v) => {\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(v - prev, getFrameData().delta);\n            if ((heading === 1 && v > boundary) ||\n                (heading === -1 && v < boundary)) {\n                startSpring({ from: v, to: boundary, velocity });\n            }\n        };\n        startAnimation({\n            type: \"decay\",\n            from,\n            velocity,\n            timeConstant,\n            power,\n            restDelta,\n            modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,\n        });\n    }\n    return {\n        stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(),\n    };\n}\n\nexport { inertia };\n"]},"metadata":{},"sourceType":"module"}