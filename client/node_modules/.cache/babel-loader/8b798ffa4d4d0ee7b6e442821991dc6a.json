{"ast":null,"code":"import { __rest, __assign } from 'tslib';\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\n\nvar observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\n\nvar observers = new WeakMap();\n\nvar fireObserverCallback = function (entry) {\n  var _a;\n\n  (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\n\nvar fireAllObserverCallbacks = function (entries) {\n  entries.forEach(fireObserverCallback);\n};\n\nfunction initIntersectionObserver(_a) {\n  var root = _a.root,\n      options = __rest(_a, [\"root\"]);\n\n  var lookupRoot = root || document;\n  /**\n   * If we don't have an observer lookup map for this root, create one.\n   */\n\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n\n  var rootObservers = observers.get(lookupRoot);\n  var key = JSON.stringify(options);\n  /**\n   * If we don't have an observer for this combination of root and settings,\n   * create one.\n   */\n\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign({\n      root: root\n    }, options));\n  }\n\n  return rootObservers[key];\n}\n\nfunction observeIntersection(element, options, callback) {\n  var rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return function () {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\n\nexport { observeIntersection };","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"names":["__rest","__assign","observerCallbacks","WeakMap","observers","fireObserverCallback","entry","_a","get","target","fireAllObserverCallbacks","entries","forEach","initIntersectionObserver","root","options","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","observeIntersection","element","callback","rootInteresectionObserver","observe","delete","unobserve"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,QAAjB,QAAiC,OAAjC;AAEA;AACA;AACA;AACA;AACA;;AACA,IAAIC,iBAAiB,GAAG,IAAIC,OAAJ,EAAxB;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,SAAS,GAAG,IAAID,OAAJ,EAAhB;;AACA,IAAIE,oBAAoB,GAAG,UAAUC,KAAV,EAAiB;AACxC,MAAIC,EAAJ;;AACA,GAACA,EAAE,GAAGL,iBAAiB,CAACM,GAAlB,CAAsBF,KAAK,CAACG,MAA5B,CAAN,MAA+C,IAA/C,IAAuDF,EAAE,KAAK,KAAK,CAAnE,GAAuE,KAAK,CAA5E,GAAgFA,EAAE,CAACD,KAAD,CAAlF;AACH,CAHD;;AAIA,IAAII,wBAAwB,GAAG,UAAUC,OAAV,EAAmB;AAC9CA,EAAAA,OAAO,CAACC,OAAR,CAAgBP,oBAAhB;AACH,CAFD;;AAGA,SAASQ,wBAAT,CAAkCN,EAAlC,EAAsC;AAClC,MAAIO,IAAI,GAAGP,EAAE,CAACO,IAAd;AAAA,MAAoBC,OAAO,GAAGf,MAAM,CAACO,EAAD,EAAK,CAAC,MAAD,CAAL,CAApC;;AACA,MAAIS,UAAU,GAAGF,IAAI,IAAIG,QAAzB;AACA;AACJ;AACA;;AACI,MAAI,CAACb,SAAS,CAACc,GAAV,CAAcF,UAAd,CAAL,EAAgC;AAC5BZ,IAAAA,SAAS,CAACe,GAAV,CAAcH,UAAd,EAA0B,EAA1B;AACH;;AACD,MAAII,aAAa,GAAGhB,SAAS,CAACI,GAAV,CAAcQ,UAAd,CAApB;AACA,MAAIK,GAAG,GAAGC,IAAI,CAACC,SAAL,CAAeR,OAAf,CAAV;AACA;AACJ;AACA;AACA;;AACI,MAAI,CAACK,aAAa,CAACC,GAAD,CAAlB,EAAyB;AACrBD,IAAAA,aAAa,CAACC,GAAD,CAAb,GAAqB,IAAIG,oBAAJ,CAAyBd,wBAAzB,EAAmDT,QAAQ,CAAC;AAAEa,MAAAA,IAAI,EAAEA;AAAR,KAAD,EAAiBC,OAAjB,CAA3D,CAArB;AACH;;AACD,SAAOK,aAAa,CAACC,GAAD,CAApB;AACH;;AACD,SAASI,mBAAT,CAA6BC,OAA7B,EAAsCX,OAAtC,EAA+CY,QAA/C,EAAyD;AACrD,MAAIC,yBAAyB,GAAGf,wBAAwB,CAACE,OAAD,CAAxD;AACAb,EAAAA,iBAAiB,CAACiB,GAAlB,CAAsBO,OAAtB,EAA+BC,QAA/B;AACAC,EAAAA,yBAAyB,CAACC,OAA1B,CAAkCH,OAAlC;AACA,SAAO,YAAY;AACfxB,IAAAA,iBAAiB,CAAC4B,MAAlB,CAAyBJ,OAAzB;AACAE,IAAAA,yBAAyB,CAACG,SAA1B,CAAoCL,OAApC;AACH,GAHD;AAIH;;AAED,SAASD,mBAAT","sourcesContent":["import { __rest, __assign } from 'tslib';\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nvar observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nvar observers = new WeakMap();\nvar fireObserverCallback = function (entry) {\n    var _a;\n    (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\nvar fireAllObserverCallbacks = function (entries) {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n    var root = _a.root, options = __rest(_a, [\"root\"]);\n    var lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    var rootObservers = observers.get(lookupRoot);\n    var key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign({ root: root }, options));\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    var rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return function () {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n"]},"metadata":{},"sourceType":"module"}