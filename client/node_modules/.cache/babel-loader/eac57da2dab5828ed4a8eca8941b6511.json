{"ast":null,"code":"import { linear } from './index.mjs';\n\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\n\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\n\nconst c = a1 => 3.0 * a1;\n\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n\n  return currentT;\n}\n\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i = 0; i < newtonIterations; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2) return linear;\n  const sampleValues = new Float32Array(kSplineTableSize);\n\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/popmotion/dist/es/easing/cubic-bezier.mjs"],"names":["linear","a","a1","a2","b","c","calcBezier","t","getSlope","subdivisionPrecision","subdivisionMaxIterations","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","newtonIterations","newtonMinSlope","newtonRaphsonIterate","aGuessT","currentSlope","kSplineTableSize","kSampleStepSize","cubicBezier","mY1","mY2","sampleValues","Float32Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope"],"mappings":"AAAA,SAASA,MAAT,QAAuB,aAAvB;;AAEA,MAAMC,CAAC,GAAG,CAACC,EAAD,EAAKC,EAAL,KAAY,MAAM,MAAMA,EAAZ,GAAiB,MAAMD,EAA7C;;AACA,MAAME,CAAC,GAAG,CAACF,EAAD,EAAKC,EAAL,KAAY,MAAMA,EAAN,GAAW,MAAMD,EAAvC;;AACA,MAAMG,CAAC,GAAIH,EAAD,IAAQ,MAAMA,EAAxB;;AACA,MAAMI,UAAU,GAAG,CAACC,CAAD,EAAIL,EAAJ,EAAQC,EAAR,KAAe,CAAC,CAACF,CAAC,CAACC,EAAD,EAAKC,EAAL,CAAD,GAAYI,CAAZ,GAAgBH,CAAC,CAACF,EAAD,EAAKC,EAAL,CAAlB,IAA8BI,CAA9B,GAAkCF,CAAC,CAACH,EAAD,CAApC,IAA4CK,CAA9E;;AACA,MAAMC,QAAQ,GAAG,CAACD,CAAD,EAAIL,EAAJ,EAAQC,EAAR,KAAe,MAAMF,CAAC,CAACC,EAAD,EAAKC,EAAL,CAAP,GAAkBI,CAAlB,GAAsBA,CAAtB,GAA0B,MAAMH,CAAC,CAACF,EAAD,EAAKC,EAAL,CAAP,GAAkBI,CAA5C,GAAgDF,CAAC,CAACH,EAAD,CAAjF;;AACA,MAAMO,oBAAoB,GAAG,SAA7B;AACA,MAAMC,wBAAwB,GAAG,EAAjC;;AACA,SAASC,eAAT,CAAyBC,EAAzB,EAA6BC,EAA7B,EAAiCC,EAAjC,EAAqCC,GAArC,EAA0CC,GAA1C,EAA+C;AAC3C,MAAIC,QAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,CAAC,GAAG,CAAR;;AACA,KAAG;AACCD,IAAAA,QAAQ,GAAGL,EAAE,GAAG,CAACC,EAAE,GAAGD,EAAN,IAAY,GAA5B;AACAI,IAAAA,QAAQ,GAAGX,UAAU,CAACY,QAAD,EAAWH,GAAX,EAAgBC,GAAhB,CAAV,GAAiCJ,EAA5C;;AACA,QAAIK,QAAQ,GAAG,GAAf,EAAoB;AAChBH,MAAAA,EAAE,GAAGI,QAAL;AACH,KAFD,MAGK;AACDL,MAAAA,EAAE,GAAGK,QAAL;AACH;AACJ,GATD,QASSE,IAAI,CAACC,GAAL,CAASJ,QAAT,IAAqBR,oBAArB,IACL,EAAEU,CAAF,GAAMT,wBAVV;;AAWA,SAAOQ,QAAP;AACH;;AACD,MAAMI,gBAAgB,GAAG,CAAzB;AACA,MAAMC,cAAc,GAAG,KAAvB;;AACA,SAASC,oBAAT,CAA8BZ,EAA9B,EAAkCa,OAAlC,EAA2CV,GAA3C,EAAgDC,GAAhD,EAAqD;AACjD,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,gBAApB,EAAsC,EAAEH,CAAxC,EAA2C;AACvC,UAAMO,YAAY,GAAGlB,QAAQ,CAACiB,OAAD,EAAUV,GAAV,EAAeC,GAAf,CAA7B;;AACA,QAAIU,YAAY,KAAK,GAArB,EAA0B;AACtB,aAAOD,OAAP;AACH;;AACD,UAAMR,QAAQ,GAAGX,UAAU,CAACmB,OAAD,EAAUV,GAAV,EAAeC,GAAf,CAAV,GAAgCJ,EAAjD;AACAa,IAAAA,OAAO,IAAIR,QAAQ,GAAGS,YAAtB;AACH;;AACD,SAAOD,OAAP;AACH;;AACD,MAAME,gBAAgB,GAAG,EAAzB;AACA,MAAMC,eAAe,GAAG,OAAOD,gBAAgB,GAAG,GAA1B,CAAxB;;AACA,SAASE,WAAT,CAAqBd,GAArB,EAA0Be,GAA1B,EAA+Bd,GAA/B,EAAoCe,GAApC,EAAyC;AACrC,MAAIhB,GAAG,KAAKe,GAAR,IAAed,GAAG,KAAKe,GAA3B,EACI,OAAO/B,MAAP;AACJ,QAAMgC,YAAY,GAAG,IAAIC,YAAJ,CAAiBN,gBAAjB,CAArB;;AACA,OAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,gBAApB,EAAsC,EAAER,CAAxC,EAA2C;AACvCa,IAAAA,YAAY,CAACb,CAAD,CAAZ,GAAkBb,UAAU,CAACa,CAAC,GAAGS,eAAL,EAAsBb,GAAtB,EAA2BC,GAA3B,CAA5B;AACH;;AACD,WAASkB,QAAT,CAAkBtB,EAAlB,EAAsB;AAClB,QAAIuB,aAAa,GAAG,GAApB;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,UAAMC,UAAU,GAAGV,gBAAgB,GAAG,CAAtC;;AACA,WAAOS,aAAa,KAAKC,UAAlB,IAAgCL,YAAY,CAACI,aAAD,CAAZ,IAA+BxB,EAAtE,EAA0E,EAAEwB,aAA5E,EAA2F;AACvFD,MAAAA,aAAa,IAAIP,eAAjB;AACH;;AACD,MAAEQ,aAAF;AACA,UAAME,IAAI,GAAG,CAAC1B,EAAE,GAAGoB,YAAY,CAACI,aAAD,CAAlB,KACRJ,YAAY,CAACI,aAAa,GAAG,CAAjB,CAAZ,GAAkCJ,YAAY,CAACI,aAAD,CADtC,CAAb;AAEA,UAAMG,SAAS,GAAGJ,aAAa,GAAGG,IAAI,GAAGV,eAAzC;AACA,UAAMY,YAAY,GAAGhC,QAAQ,CAAC+B,SAAD,EAAYxB,GAAZ,EAAiBC,GAAjB,CAA7B;;AACA,QAAIwB,YAAY,IAAIjB,cAApB,EAAoC;AAChC,aAAOC,oBAAoB,CAACZ,EAAD,EAAK2B,SAAL,EAAgBxB,GAAhB,EAAqBC,GAArB,CAA3B;AACH,KAFD,MAGK,IAAIwB,YAAY,KAAK,GAArB,EAA0B;AAC3B,aAAOD,SAAP;AACH,KAFI,MAGA;AACD,aAAO5B,eAAe,CAACC,EAAD,EAAKuB,aAAL,EAAoBA,aAAa,GAAGP,eAApC,EAAqDb,GAArD,EAA0DC,GAA1D,CAAtB;AACH;AACJ;;AACD,SAAQT,CAAD,IAAOA,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAK,CAAjB,GAAqBA,CAArB,GAAyBD,UAAU,CAAC4B,QAAQ,CAAC3B,CAAD,CAAT,EAAcuB,GAAd,EAAmBC,GAAnB,CAAjD;AACH;;AAED,SAASF,WAAT","sourcesContent":["import { linear } from './index.mjs';\n\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\nconst c = (a1) => 3.0 * a1;\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        }\n        else {\n            aA = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (let i = 0; i < newtonIterations; ++i) {\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2)\n        return linear;\n    const sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        else if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n"]},"metadata":{},"sourceType":"module"}