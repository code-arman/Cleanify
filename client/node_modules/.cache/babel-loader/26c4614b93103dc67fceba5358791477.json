{"ast":null,"code":"import { __assign } from 'tslib';\nimport * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { useFeatures } from './features/use-features.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { loadFeatures, featureDefinitions } from './features/definitions.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { useProjectionId } from '../projection/node/id.mjs';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { useProjection } from './features/use-projection.mjs';\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\nfunction createMotionComponent(_a) {\n  var preloadedFeatures = _a.preloadedFeatures,\n      createVisualElement = _a.createVisualElement,\n      projectionNodeConstructor = _a.projectionNodeConstructor,\n      useRender = _a.useRender,\n      useVisualState = _a.useVisualState,\n      Component = _a.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n\n  function MotionComponent(props, externalRef) {\n    var layoutId = useLayoutId(props);\n    props = __assign(__assign({}, props), {\n      layoutId: layoutId\n    });\n    /**\n     * If we're rendering in a static environment, we only visually update the component\n     * as a result of a React-rerender rather than interactions or animations. This\n     * means we don't need to load additional memory structures like VisualElement,\n     * or any gesture/animation features.\n     */\n\n    var config = useContext(MotionConfigContext);\n    var features = null;\n    var context = useCreateMotionContext(props);\n    /**\n     * Create a unique projection ID for this component. If a new component is added\n     * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\n     * us to measure it as soon as any layout effect flushes pending layout animations.\n     *\n     * Performance note: It'd be better not to have to search the DOM for these elements.\n     * For newly-entering components it could be enough to only correct treeScale, in which\n     * case we could mount in a scale-correction mode. This wouldn't be enough for\n     * shared element transitions however. Perhaps for those we could revert to a root node\n     * that gets forceRendered and layout animations are triggered on its layout effect.\n     */\n\n    var projectionId = config.isStatic ? undefined : useProjectionId();\n    /**\n     *\n     */\n\n    var visualState = useVisualState(props, config.isStatic);\n\n    if (!config.isStatic && isBrowser) {\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, __assign(__assign({}, config), props), createVisualElement);\n      useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);\n      /**\n       * Load Motion gesture and animation features. These are rendered as renderless\n       * components so each feature can optionally make use of React lifecycle methods.\n       */\n\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n\n\n    return React.createElement(VisualElementHandler, {\n      visualElement: context.visualElement,\n      props: __assign(__assign({}, config), props)\n    }, features, React.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement)));\n  }\n\n  return forwardRef(MotionComponent);\n}\n\nfunction useLayoutId(_a) {\n  var _b;\n\n  var layoutId = _a.layoutId;\n  var layoutGroupId = (_b = useContext(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\nexport { createMotionComponent };","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/framer-motion/dist/es/motion/index.mjs"],"names":["__assign","React","forwardRef","useContext","useFeatures","MotionConfigContext","MotionContext","useVisualElement","useMotionRef","useCreateMotionContext","loadFeatures","featureDefinitions","isBrowser","useProjectionId","LayoutGroupContext","useProjection","VisualElementHandler","createMotionComponent","_a","preloadedFeatures","createVisualElement","projectionNodeConstructor","useRender","useVisualState","Component","MotionComponent","props","externalRef","layoutId","useLayoutId","config","features","context","projectionId","isStatic","undefined","visualState","visualElement","createElement","Provider","value","_b","layoutGroupId","id"],"mappings":"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","sourcesContent":["import { __assign } from 'tslib';\nimport * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { useFeatures } from './features/use-features.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { loadFeatures, featureDefinitions } from './features/definitions.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { useProjectionId } from '../projection/node/id.mjs';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { useProjection } from './features/use-projection.mjs';\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, projectionNodeConstructor = _a.projectionNodeConstructor, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        var layoutId = useLayoutId(props);\n        props = __assign(__assign({}, props), { layoutId: layoutId });\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */\n        var config = useContext(MotionConfigContext);\n        var features = null;\n        var context = useCreateMotionContext(props);\n        /**\n         * Create a unique projection ID for this component. If a new component is added\n         * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\n         * us to measure it as soon as any layout effect flushes pending layout animations.\n         *\n         * Performance note: It'd be better not to have to search the DOM for these elements.\n         * For newly-entering components it could be enough to only correct treeScale, in which\n         * case we could mount in a scale-correction mode. This wouldn't be enough for\n         * shared element transitions however. Perhaps for those we could revert to a root node\n         * that gets forceRendered and layout animations are triggered on its layout effect.\n         */\n        var projectionId = config.isStatic ? undefined : useProjectionId();\n        /**\n         *\n         */\n        var visualState = useVisualState(props, config.isStatic);\n        if (!config.isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, __assign(__assign({}, config), props), createVisualElement);\n            useProjection(projectionId, props, context.visualElement, projectionNodeConstructor ||\n                featureDefinitions.projectionNodeConstructor);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             */\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (React.createElement(VisualElementHandler, { visualElement: context.visualElement, props: __assign(__assign({}, config), props) },\n            features,\n            React.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement))));\n    }\n    return forwardRef(MotionComponent);\n}\nfunction useLayoutId(_a) {\n    var _b;\n    var layoutId = _a.layoutId;\n    var layoutGroupId = (_b = useContext(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\n\nexport { createMotionComponent };\n"]},"metadata":{},"sourceType":"module"}